{"data":{"allMarkdownRemark":{"nodes":[{"id":"a58b5202-7367-5546-947b-5cede329ab3d","frontmatter":{"title":"git commit을 입력하면 일어나는 일","icon":"TbBrandGithub","date":"July 29, 2023"},"fields":{"slug":"/git-and-github/"},"rawMarkdownBody":"\r\n# 너무나도 당연하게 사용하는 git\r\n\r\n> 개발자라면 git은 당연하게 쓰지 않아?\r\n\r\n<br/>\r\n\r\n개발 공부를 하기 위해 가장 기초적인 파트 중 하나인 `git`, 여러분은 얼마나 알고 계신가요? 단순히 `add`, `commit`, `push` 등의 명령어를 통해 상태가 변화하더라! 저는 여기까지만 알고 있었습니다. 2005년 6월에 리누스 토발즈에 의해 공개된 git이 이제는 개발자라면 당연히 사용할 수 있어야 하는 버전 관리 시스템이 된 지금, 우리는 git에 대해 얼마나 알고 사용하고 있나요?\r\n\r\n![https://support.nesi.org.nz/hc/en-gb/articles/360001508515-Git-Reference-Sheet](gitReferenceSheet.png)\r\n\r\n혹 단순히 이 정도로만 알고 계시지는 않았나요? git 내부는 어떻게 동작하는가에 대해 함께 알아봅시다.\r\n\r\n## git과 스냅샷\r\n\r\n다른 버전 관리 시스템과 git의 가장 큰 차이점은 **차이와 스냅샷**입니다. 이전의 시스템들은 각 파일의 변화를 시간순으로 관리하였습니다. 아래 이미지를 살펴봅시다.\r\n\r\n![https://git-scm.com/book/ko/v2/시작하기-Git-기초](snapShot1.png)\r\n\r\n각 파일의 변경점에 대해 버전 단위로 이를 관리하는 모습을 볼 수 있습니다. 이를 **델타 기반 버전 관리 시스템** 이라고 합니다. 맞습니다! 수학에서의 `Δ`와 비슷한 의미라 할 수 있겠습니다. **변화량, 다른 말로 차이**가 될 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n하지만 git은 파일들의 차이, 변화보다는 **스냅샷**에 집중했습니다. 파일이 달라지지 않았으면 git은 성능을 위해 새로 저장하지 않고, 이전 상태의 파일 링크를 저장하는 방식으로 구성하였습니다.\r\n\r\n![https://git-scm.com/book/ko/v2/시작하기-Git-기초](snapShot2.png)\r\n\r\n기존의 델타 방식은 파일에 변화가 생겼을 때 \"변화된 사항\"만 기록했다면, git은 변화가 생기면 이를 통째로 기록한다는 것에서 차이가 있습니다. 근데 이게 효율적인가요? 이렇게 생각해봅시다.\r\n\r\n<br/>\r\n\r\n> **Q. 어떤 한 파일이 1000번 수정된 상태입니다.\r\n> 여기서 512번째 상태의 파일을 확인해보고 싶습니다.**\r\n>\r\n> - 델타 방식은 처음부터 변화를 탐색하여 512번째까지 진행해야 해당 상태의 파일을 확인할 수 있습니다.\r\n> - 스냅샷 방식은 그냥 512번째 파일을 확인하면 그만입니다.\r\n\r\n<br/>\r\n\r\n바로 이러한 부분에서 git이 버전 관리에 더 용이하다고 할 수 있습니다.\r\n\r\n## git 파일 상태\r\n\r\n> **git이 하는 일**\r\n>\r\n> 1. working tree에서 파일을 수정\r\n> 2. Staging Area에 파일을 stage하여 commit할 스냅샷을 생성\r\n> 3. Staging Area에 있는 파일들을 commit하여 영구적인 스냅샷으로 저장\r\n\r\n<br/>\r\n\r\n여기서 working tree는 우리가 작업하는 폴더라고 쉽게 생각할 수 있습니다. 쉽게 말해 **수정한 파일들에 대한 스냅샷을 남기기 위해 staging area에 모아 이를 하나의 스냅샷으로 저장한다**라고 이해합시다. 이를 바로 **Git directory**에 저장하게 됩니다. 즉, **git directory**는 프로젝트의 데이터를 저장하는 곳이자 핵심이라고 할 수 있겠습니다.\r\n\r\n![https://git-scm.com/book/ko/v2/시작하기-Git-기초](gitDirectory.png)\r\n\r\n위와 같이 `git add`를 이용해 Staged 상태로 변경하고, 이를 모아 `git commit`을 통해 버전 관리를 진행하게 됩니다. 여기서 git은 파일을 상태를 가지고 구분하여 작업합니다. 각 과정에서 어떻게 동작하는지를 파악하기 이전에 가볍게 확인하고 넘어가겠습니다.\r\n\r\n![https://git-scm.com/book/ko/v2/Git의-기초-수정하고-저장소에-저장하기](gitStatus.png)\r\n\r\n> **git 파일의 상태**\r\n>\r\n> - `untracked` : 아직 git의 관리 대상이 아닌 파일을 의미\r\n> - `unmodified` : 아무런 수정 사항이 없는 파일\r\n> - `modified` : 수정된 파일\r\n> - `staged` : commit되기 이전 상태\r\n\r\n여기서 `staged`는 `staging area`에 있는 파일을 의미합니다. 이러한 사이클을 바탕으로 파일의 상태를 변경하게 됩니다.\r\n\r\n## Git 개체\r\n\r\ngit은 `.git` directory 내부에 스냅샷과 더불어 버전 관리를 위한 다양한 정보를 저장합니다. 내부적으로 object 단위로 관리하며 여기에는 `commit`, `tree`,`blob`, `tag` 총 4가지 타입이 존재합니다.\r\n\r\n<br/>\r\n\r\n![](capture1.png)\r\n\r\n<br/>\r\n\r\n우선 `git init`을 하면 `.git` directory가 생성됩니다. 그 내부에 `objects` directory에 위에서 언급한 4가지 타입의 object들이 저장됩니다. 각 타입별로 구분하여 저장하지는 않습니다. `init`만 진행하고 아무것도 하지 않은 `objects` directory 내부를 살펴봅시다.\r\n\r\n<br/>\r\n\r\n![](capture2.png)\r\n\r\n<br/>\r\n\r\n여기서 `pack`과 `info`는 object 파일이 아닙니다. 이러한 object 파일은 어떤 방식으로 저장될까요? `hello.txt`라는 파일을 추가했다면, 동일한 이름을 가진 object 파일을 생성하여 저장할까요? 아쉽게도 이렇게 동작하지는 않습니다.\r\n\r\n### Git과 체크섬\r\n\r\n체크섬은 **암호 검사합**이라고도 부르며, 파일 안에 있는 데이터를 hash한 해시값입니다. git은 이러한 체크섬으로(쉽게 이해하자면 해시값으로) 데이터를 관리하는데, 정확히는 `SHA-1` 해시를 사용하여 해시값을 얻습니다.\r\n\r\n<br/>\r\n\r\n이를 쉽게 풀어보자면 **파일의 내용을 `SHA-1` 해시를 사용해 해시값으로 변경하여 이를 바탕으로 데이터를 저장한다**고 할 수 있겠습니다. 정확히는 `blob, tree, commit` 등에 따라 앞에 헤더를 붙여 이에 대한 체크섬을 사용합니다. 이때 생성되는 해시값은 **40자 길이의 16진수 문자열**입니다. 이를 바로 **object 파일의 이름**으로 지정하여 저장합니다. 즉, 이 해시값을 이용하여 파일을 식별하게 됩니다. 하지만 이 역시 바로 파일 형태로 저장하지는 않습니다.\r\n\r\n<br/>\r\n\r\n정확히는 **파일 이름 중 앞 2글자는 directory 이름으로, 나머지 38글자를 파일 이름으로 사용**합니다. 이 이유는 무엇일까요?\r\n\r\n<br/>\r\n\r\n![](capture3.png)\r\n\r\n<br/>\r\n\r\n위는 여러번 commit을 진행한 `.git/objects` 내부입니다. 복잡한 프로젝트라면 버전 관리를 위해 이러한 object 파일들이 많아질텐데, 이를 하나의 폴더에 전부 저장하고, 여기서 하나의 파일을 찾는다면 쉽게 찾을 수 있을까요? 한 폴더에 파일이 많이 존재하면 파일 시스템의 성능 저하가 있을 수 있기 때문에 폴더를 구분하여 저장하게 됩니다.\r\n\r\n### blob\r\n\r\n![](capture4.png)\r\n\r\n<br/>\r\n\r\n`blob`은 `git add`시에 생성됩니다. 수정된 파일을 `staged` 상태로 변경하는 과정에 해당됩니다. `add`의 대상이 되는 파일의 내용에 대한 체크섬으로 `blob object` 파일을 생성합니다. 해당 파일의 내부에는 `zlib`으로 파일 내용을 압축한 값이 저장되게 됩니다.\r\n\r\n<br/>\r\n\r\n> [`zlib`](https://ko.wikipedia.org/wiki/Zlib)은 데이터 압축 라이브러리입니다.\r\n\r\n<br/>\r\n\r\n여기서 **파일의 내용에 대한 체크섬이 blob의 이름**이 된다는 부분이 앞에서 언급한 **파일이 달라지지 않았다면 새로 저장하지 않는다**와 관련이 있습니다. 파일명은 고려하지 않고 파일의 내용만 고려하기 때문에, 파일 내용이 동일하고 파일 이름은 다른 파일이 존재한다면 이에 대한 `blob`을 따로 생성하지 않습니다. 둘 다 파일의 내용은 동일하기 때문에 하나의 `blob`만 생성합니다.\r\n\r\n<br/>\r\n\r\n그런데... 파일 이름은 어디에 저장하죠? 바로 다음에 다룰 `tree` object에 저장하게 됩니다.\r\n\r\n### tree\r\n\r\n`tree` object는 `git commit` 과정에서 생성되는 파일입니다. 여기에 파일 이름을 저장하게 됩니다. 저장되는 값을 살펴보자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n```\r\n$ git cat-file -p master^{tree}\r\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\r\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\r\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\r\n```\r\n\r\n<br/>\r\n\r\n위 예시에는 `blob` 파일 2개와 `tree` 파일 하나가 저장되어 있습니다. `tree` object는 다르게 말하자면 `staging area`의 스냅샷이라 할 수 있습니다. `commit`하기 위한 `staged`된 파일들에 대한 정보를 스냅샷 형태로 저장하는 것이 목적입니다.\r\n\r\n<br/>\r\n\r\n여기서 `tree`는 하위 directory의 `tree`에 해당합니다. 하위 `tree` 객체를 포함하여 저장하는 방식으로 재귀적으로 참조가 가능하도록 저장한 것입니다. 위 예시를 그림으로 나타내면 아래와 같습니다.\r\n\r\n![https://git-scm.com/book/ko/v2/Git의-내부-Git-개체](gitTree.png)\r\n\r\n이러한 `tree` object 역시 저장될 위의 내용에 대한 체크섬으로 파일명을 지정하여 저장하게 됩니다. 내부 내용 역시 `zlib`을 이용해 압축하여 저장합니다.\r\n\r\n### commit\r\n\r\n그런데 `tree`로 저장한 이 스냅샷을 어떻게 불러와야 할까요? 아직까지는 이 스냅샷을 불러오기 위해서 해당 `SHA-1` 값을 알고 있어야 합니다. 또한 이러한 스냅샷을 **누가, 언제, 왜 저장했는지**에 대한 정보도 존재하지 않습니다. 이러한 정보를 바로 `commit` object에 저장하게 됩니다. 이에 대한 예시를 살펴보겠습니다.\r\n\r\n<br/>\r\n\r\n```\r\n$ git cat-file -p fdf4fc3\r\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\r\nauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\r\ncommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700\r\n\r\nfirst commit\r\n```\r\n\r\n<br/>\r\n\r\n`commit` 내부에는 스냅샷의 최상단 `tree`에 대한 정보와 누가, 언제, 왜 저장했는지에 대한 정보, 그리고 commit message가 담기게 됩니다. 역시 해당 내용에 대한 체크섬으로 파일 이름을 설정하여 저장하며, 파일 내부 내용은 `zlib`으로 압축하여 저장합니다.\r\n\r\n<br/>\r\n\r\n또한 이전 `commit` 객체를 가리켜 history를 관리하기 위해 이전 `commit`에 대한 정보도 담고 있습니다. (이를 부모 `commit`이라고 부르기도 합니다.) 이러한 구조를 그려보자면 아래와 같습니다.\r\n\r\n![https://git-scm.com/book/ko/v2/Git의-내부-Git-개체](gitCommit.png)\r\n\r\n## git과 세 개의 트리\r\n\r\n각 단계에서 어떠한 방식으로 git이 파일을 저장하고 그 목적이 무엇인지에 대해 알아보았습니다. 그렇다면 git은 어떻게 이러한 파일들을 관리하고 추적할까요?\r\n\r\n<br/>\r\n\r\ngit은 서로 다른 세 개의 트리를 관리하는 관리자라고 할 수 있습니다. 여기서 트리는 **파일의 묶음**이라고 칭합니다. (자료구조의 트리를 잠시 잊어주세요. 그냥 파일이라 생각합시다.)\r\n\r\n| 트리              | 역할                                                     |\r\n| ----------------- | -------------------------------------------------------- |\r\n| HEAD              | 마지막 commit의 스냅샷, 다음 commit의 부모 commit        |\r\n| Index             | 다음에 commit할 스냅샷 (사실 트리에 해당하지는 않습니다) |\r\n| Working Directory | 샌드박스                                                 |\r\n\r\n### HEAD\r\n\r\n`HEAD`는 현재 branch를 가리키는 포인터입니다. 다시 말해 **현재 branch의 마지막 commit의 스냅샷**이라고 할 수 있습니다. 그래서 branch는 뭔가요? branch의 개념은 자세하게 다루지 않았으니 이를 염두하고 생각하자면 가장 마지막 commit에 대한 스냅샷을 가리키는 포인터라고 이해할 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n```\r\n$ git cat-file -p HEAD\r\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\r\nauthor Scott Chacon  1301511835 -0700\r\ncommitter Scott Chacon  1301511835 -0700\r\n```\r\n\r\n<br/>\r\n\r\n`commit` object와 형태가 동일한 것을 확인할 수 있습니다. 이러한 `HEAD`를 이용하여 가장 최근 `commit`에 접근하고, 해당 `commit` object가 가리키는 부모 `commit`으로 이동하며 `commit` 기록을 확인할 수 있습니다.\r\n\r\n### Index\r\n\r\n`Index`는 바로 다음에 `commit`할 내용들을 보관하고 있습니다. 이를 다시 말하면 `Staging Area`라고 할 수 있겠습니다. 즉, `git commit` 명령어를 입력했을 때, 어떤 파일들을 처리해야 하는지에 대한 정보를 담고 있다고 생각할 수 있습니다. `Index`의 내부는 아래와 같은 정보를 담고 있습니다.\r\n\r\n<br/>\r\n\r\n```\r\n$ git ls-files -s\r\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\r\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\r\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\r\n```\r\n\r\n<br/>\r\n\r\n즉, 변경된 파일들에 대한 정보(`blob`)를 담고 있습니다. 이러한 `Index`는 `git commit` 명령을 실행하면 새로운 `commit`으로 변환(내부 내용을 초기화)하여 `staged` 상태의 파일을 관리합니다.\r\n\r\n### Working Directory\r\n\r\n`Working Directory`는 실제 파일로 존재하는 **우리가 실제로 작업하는 공간**입니다. 파일을 생성, 작성하고 수정, 삭제하는 실제 directory에 해당합니다. 즉, `Working directory`에서 변경된 정보를 `git add`시에 `Index`에 저장하고, 이를 바탕으로 `commit`을 진행하게 됩니다.\r\n\r\n# 글을 마무리하며...\r\n\r\n매번 구글링해서 사용하기 바빴던 `git`에서 `git init`, `git add`, `git commit` 명령어를 입력했을 때, 내부적으로 어떻게 동작하여 상태 관리를 진행하는지 살펴보았습니다. 이 이외에도 `ref`와 `tag`, 그리고 다양한 `branch`들은 어떻게 관리하는지에 대해 고민하고 학습해볼 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n이번 포스팅의 내용을 간단히 정리해보자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> **commit까지의 동작 과정**\r\n>\r\n> - git add시에 각 파일을 `blob`으로 저장\r\n> - `blob`에 대한 정보를 `Index`에 저장\r\n> - `git commit` 시에 `Index`를 참고하여 `tree` 객체를 생성\r\n> - `tree`에 대한 `commit` 객체를 생성하여 저장\r\n\r\n<br/>\r\n\r\n부족한 글 읽어주셔서 감사드리며, 잘못된 부분이 존재하거나 궁금한 점이 있으시다면 댓글 남겨주시면 감사드리겠습니다.\r\n\r\n# 참고 자료\r\n\r\n- https://nozeroslope.tistory.com/186\r\n- https://namu.wiki/w/%CE%94\r\n- https://yozm.wishket.com/magazine/detail/1674/\r\n- https://joone.net/2022/10/02/47-git/\r\n- https://wansook0316.github.io/dv/ios/2021/08/08/Git-Structure.html\r\n- https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EB%82%B4%EB%B6%80-Git-%EA%B0%9C%EC%B2%B4\r\n- https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0\r\n- https://nozeroslope.tistory.com/186\r\n- https://storycompiler.tistory.com/7\r\n"},{"id":"ff4e6387-6759-53f9-8a3a-f769620d392d","frontmatter":{"title":"[Boarlog] 아름다운 카드 Flip 효과 구현하기","icon":"TbCards","date":"November 28, 2023"},"fields":{"slug":"/boarlog/flip-card/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n<br/>\r\n\r\n> **구현 결과물 미리보기**\r\n>\r\n> ![](result.gif)\r\n\r\n## 구현하고자 하는 것은?\r\n\r\n프로젝트를 진행하며 가장 중요하게 생각했던 것은 **\"복잡하게 구성하지 말자\"**는 것입니다. 시간은 한정되어 있고, 짧은 기간 내에 프로젝트를 끝내야 했기 때문에 UI 구성을 최대한 단순하게 가져가는 것을 목표로 했습니다.\r\n\r\n<br/>\r\n\r\n메인 페이지를 디자인하는 과정에서 강의를 들을 수 있는 방을 개설하거나 개설된 방에 참여하는 UI를 단순히 보여주는 것으로 간단히 구성할 수 있었지만, 추가적인 정보를 전달해주고자 앞면에는 해당 기능에 대한 정보, 뒷면에는 기능과 관련된 요소가 존재하는 카드 형태를 구상하게 되었습니다.\r\n\r\n<br/>\r\n\r\n![](startUI.png)\r\n\r\n<br/>\r\n\r\n버튼을 클릭하면 해당 요소가 바로 표시되도록 간단하게 구현이 가능했지만, **보다 동적인 느낌을 주고자** 카드를 뒤집는 것 같은 Flip 효과를 구현하게 되었습니다.\r\n\r\n## 간단한 예제 구성하기\r\n\r\n### html 뼈대 작성하기\r\n\r\n`<div>` 2개를 겹쳐 하나의 카드로 묶어 이를 뒤집는 형태로 구현하고자 했습니다. 전체적인 구조는 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n```html\r\n<div id=\"wrapper\">\r\n  <div id=\"card\">\r\n    <div id=\"front\" />\r\n    <div id=\"back\" />\r\n  </div>\r\n</div>\r\n```\r\n\r\n<br/>\r\n\r\n각각 `card`는 2개의 `div`를 하나로 묶는 역할을, `front`와 `back`은 각각 카드의 앞면과 뒷면을 의미하는 것은 알겠습니다. 그런데 왜 `wrapper`로 한 번 더 감싸는걸까요? 각각의 역할을 살펴봅시다.\r\n\r\n<br/>\r\n\r\n- `wrapper` : 카드의 사이즈를 결정합니다. 해당 요소의 크기를 기준으로 카드 크기를 결정합니다. 추가적으로 해당 요소를 hover시에 하위의 card를 뒤집도록 할 수 있습니다.\r\n\r\n- `card` : 해당 요소 내부에 front와 back이 겹쳐 존재하여 이를 뒤집는 것으로 카드를 뒤집는 애니메이션을 구현할 수 있습니다.\r\n\r\n<br/>\r\n\r\n`wrapper`는 카드의 크기를 결정하는 기준점이 됨은 물론, `hover`시에 카드를 뒤집고자 할때 필요합니다. 만일 `card`에 `hover`시에 카드를 뒤집게 된다면, 뒤집는 과정에서 `card`에 빈 공간이 생겨 `hover` 효과가 끊기는 경우가 발생할 수 있습니다. 그렇기에 전체를 감싸는 `wrapper`에게 `hover` 효과를 부여하여 하위 `card`가 뒤집히도록 구현한다면 `hover` 효과가 중간에 끊김을 방지할 수 있습니다.\r\n\r\n<br/>\r\n\r\n이 뿐만 아니라 `perspective` 속성을 추가하기 위해서 `wrapper`가 필요합니다. (이 부분은 뒤에서 설명하겠습니다.)\r\n\r\n### css 추가하기\r\n\r\n![](figjam.png)\r\n\r\n앞서 구성한 html 뼈대를 시각화하자면 위와 같습니다. 이제 각 부분에 css를 작성해 동작하도록 해보겠습니다.\r\n\r\n<br/>\r\n\r\n```css\r\n.wrapper {\r\n  // 요소의 크기를 여기서 결정\r\n  perspective: 1000px;\r\n}\r\n\r\n.card {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n  transition: all 0.5s;\r\n  perspective-origin: center;\r\n  transform-style: preserve-3d;\r\n}\r\n\r\n.front {\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 2;\r\n  position: absolute;\r\n  backface-visibility: hidden;\r\n}\r\n\r\n.back {\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 1;\r\n  transform: rotateY(180deg);\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n- 상위에 `relative`를 지정하고 하위 요소 2개에 `absolute`를 지정하는 것으로 카드가 겹치도록 하였습니다.\r\n\r\n- `back`은 `transform: rotateY(180deg);`를 적용하여 뒤집힌 상태로 겹쳐지도록 하였으며, 카드가 뒤집혔을 때 정상적으로 보이기 위해 해당 속성을 추가하였습니다.\r\n\r\n- `front`가 `back`에 비해 앞에 위치해야 하기 때문에 `z-index`를 달리하여 `front`가 더 높은 값을 가지도록 하였습니다.\r\n\r\n- `front`에 `ackface-visibility: hidden;`속성을 지정하여 뒤집었을 때, 뒷면이 `front`의 뒷면이 보이지 않도록 하여 `back`이 정상적으로 표시될 수 있도록 하였습니다.\r\n\r\n- 카드가 뒤집히는 애니메이션을 사실적으로 표현하기 위해 `transform-style: preserve-3d;`를 `card`에 추가하였습니다. 해당 속성은 해당 컨테이너를 3D 공간에서 렌더링하도록 지정합니다.\r\n\r\n- 관련하여 원근감을 줄 수 있는 `perspective: 1000px;`를 지정하였습니다. `perspective`의 값이 높을 수록 더욱 멀리서 보는 효과를 줄 수 있습니다.\r\n\r\n- `perspective`와 같이 사용되는 `perspective-origin: center;`는 `perspective`의 기준점을 설정해줍니다. 중앙을 기준으로 효과를 줄 수 있도록 추가하였습니다.\r\n\r\n<br/>\r\n\r\n여기서 요소 내부의 특정 버튼을 클릭하거나 요소를 hover할 경우에 card에 아래 속성을 추가하는 것으로 카드를 뒤집을 수 있습니다.\r\n\r\n<br/>\r\n\r\n```css\r\n// wrapper hover 시나 특정 이벤트 발생 시 카드 뒤집기\r\ntransform: rotateY(180deg);\r\n```\r\n\r\n<br/>\r\n\r\n### 예제를 통해 확인하기\r\n\r\n아래는 `code sandbox`에서 작성한 예제입니다.\r\n\r\n<br/>\r\n\r\n> **index.html**\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>FLIP CARD</title>\r\n    <link rel=\"stylesheet\" href=\"styles.css\" />\r\n  </head>\r\n  <body>\r\n    <div class=\"wrapper\">\r\n      <div class=\"card\">\r\n        <div class=\"front\">front</div>\r\n        <div class=\"back\">back</div>\r\n      </div>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n<br/>\r\n\r\n> **styles.css**\r\n\r\n```css\r\n.wrapper {\r\n  width: 200px;\r\n  height: 400px;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  transform: translateY(-50%);\r\n\r\n  perspective: 1000px;\r\n}\r\n\r\n.wrapper:hover .card {\r\n  transform: rotateY(180deg);\r\n}\r\n\r\n.card {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n  transition: all 0.5s;\r\n  perspective-origin: center;\r\n  transform-style: preserve-3d;\r\n\r\n  color: white;\r\n  font-size: 30px;\r\n}\r\n\r\n.front {\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 2;\r\n  position: absolute;\r\n  backface-visibility: hidden;\r\n\r\n  background-color: violet;\r\n  border-radius: 20px;\r\n  overflow: hidden;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n\r\n.back {\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 1;\r\n  transform: rotateY(180deg);\r\n\r\n  background-color: skyblue;\r\n  border-radius: 20px;\r\n  overflow: hidden;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n![](sandbox.gif)\r\n\r\n> [code sandbox 예제](https://codesandbox.io/p/sandbox/shy-cherry-zps4vy?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clpi8x0im0007356hfxruieih%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clpi8x0im0003356hj8afuioq%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clpi8x0im0004356h4a7ta44t%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clpi8x0im0006356hml6g3ins%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50.4291434373623%252C49.5708565626377%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clpi8x0im0003356hj8afuioq%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clpi8x0im0002356hontfcfeh%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Findex.html%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522id%2522%253A%2522clpi8x0im0003356hj8afuioq%2522%252C%2522activeTabId%2522%253A%2522clpi8x0im0002356hontfcfeh%2522%257D%252C%2522clpi8x0im0006356hml6g3ins%2522%253A%257B%2522id%2522%253A%2522clpi8x0im0006356hml6g3ins%2522%252C%2522activeTabId%2522%253A%2522clpi8z03u00a0356hyk1yfov7%2522%252C%2522tabs%2522%253A%255B%257B%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522id%2522%253A%2522clpi8z03u00a0356hyk1yfov7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522path%2522%253A%2522%2522%257D%255D%257D%252C%2522clpi8x0im0004356h4a7ta44t%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clpi8x0im0004356h4a7ta44t%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)\r\n\r\n## 프로젝트에 적용하기\r\n\r\n해당 코드를 바탕으로 프로젝트에 적용하였습니다. `tailwindCSS`를 활용하고 있었기에 지원하지 않는 요소들을 global로 작성하였습니다.\r\n\r\n<br/>\r\n\r\n```css\r\n.preserve-3d {\r\n  transform-style: preserve-3d;\r\n}\r\n\r\n.backface-hidden {\r\n  backface-visibility: hidden;\r\n}\r\n\r\n.rotate-180 {\r\n  transform: rotateY(180deg);\r\n}\r\n\r\n.perspective-1000 {\r\n  perspective-origin: center;\r\n  perspective: 1000px;\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n![](result.gif)\r\n\r\n<br/>\r\n\r\n메인 페이지에는 카드가 2개 존재하며, 각 카드별로 state를 두어 뒤집혔는지를 판단하였습니다. 한 쪽이 뒤집힌다면, 다른 한 쪽은 다시 앞면을 보이도록 하며, 관련된 state들을 초기화하도록 하였습니다. 또한, 단순히 `hover`시에 뒤집히도록 처리하지 않고 버튼을 클릭한 경우에 `state`를 변화시켜 카드가 뒤집히도록 구현했습니다.\r\n\r\n## 포스팅을 마치며\r\n\r\nCSS로 생각보다 다양한 애니메이션을 구현할 수 있음을 느꼈습니다. 라이브러리가 없더라도 이번에 구현해본 수준의 효과는 충분히 쉽게 만들어낼 수 있었습니다. 이후 가능하다면 해당 부분을 모듈화하여 쉽게 활용이 가능하도록 코드를 분리해보는 것도 좋을 것 같습니다.\r\n\r\n<br/>\r\n\r\n글 읽어주셔서 감사드립니다. 혹여나 틀린 부분이나 미흡한 부분이 있다면 지적해주시면 감사드리겠습니다.\r\n\r\n### 참고 자료\r\n\r\n- [perspective와 backface-visibility](https://gahyun-web-diary.tistory.com/80)\r\n- [CSS 3D 카드 뒤집기 애니메이션 효과 연출 방법](https://rgy0409.tistory.com/5052#google_vignette)\r\n- [MDN perspective](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective)\r\n- [MDN backface-visibility](https://developer.mozilla.org/en-US/docs/Web/CSS/backface-visibility)\r\n"},{"id":"3ebbf067-5d05-597d-bfe8-d3cbd289ae11","frontmatter":{"title":"[Boarlog] 우리 서비스는 모바일 사절입니다.","icon":"TbDeviceMobileOff","date":"December 13, 2023"},"fields":{"slug":"/boarlog/modernizr/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n<br/>\r\n\r\n> **구현 결과물 미리보기**\r\n>\r\n> ![](result.png)\r\n\r\n## 왜 모바일 차별하세요?\r\n\r\n부스트캠프 그룹 프로젝트는 총 6주간 진행됩니다. 주어진 기간 안에 **최소한의 MVP를 목표로 개발하는 것이 하나의 챌린지**이기 때문에 서비스에 있어서 상대적으로 중요하지 않은 부가적인 부분들은 제외하는 것이 옳다고 생각했습니다.\r\n\r\n<br/>\r\n\r\n다른 캠퍼분들과 각 팀에서 개발하고 있는 서비스를 소개하는 과정에서 저희 서비스가 모바일에서도 이용할 수 있으면 좋을 것 같다는 의견을 주셨습니다. 이를 바탕으로 대부분의 UI는 `media query`를 이용하여 반응형으로 동작할 수 있도록 작업하였으나, 문제는 **강의자 페이지**였습니다.\r\n\r\n### 강의자 페이지가 왜?\r\n\r\n강의자 페이지는 아래와 같은 기능들을 포함하고 있습니다.\r\n\r\n<br/>\r\n\r\n> **강의자 페이지 주요 기능**\r\n>\r\n> - 화이트보드에 펜으로 그림을 그릴 수 있습니다.\r\n> - 화이트보드에 포스트잇을 생성해 텍스트를 입력할 수 있습니다.\r\n> - 음성을 참여자들에게 전달할 수 있습니다.\r\n> - 참여자들이 보낸 질문들을 확인하고 이를 포스트잇으로 붙여넣을 수 있습니다.\r\n\r\n<br/>\r\n\r\n![](whiteboard.png)\r\n\r\n<br/>\r\n\r\n이러한 모든 기능들이 모바일에서도 문제없이 잘 동작하도록 구현하는데 많은 시간을 소요할 것이라 예상하였습니다. 강의자 페이지에서 사용자에게 보여줘야 할 요소들이 많았고, 핵심이 되는 화이트보드는 화면이 작아질 수록 그만큼 활용할 수 있는 크기가 작아지기 때문이기도 합니다.\r\n\r\n<br/>\r\n\r\n![](anotherUI.png)\r\n\r\n<br/>\r\n\r\n다만, 다른 페이지들은 논외에 해당합니다. 충분히 모바일 환경에서도 이용하기에 무리가 없다고 생각하여 강의자 페이지와 같은 **특정 페이지만 모바일의 접근을 제한**하기로 하였습니다.\r\n\r\n## 그런데, 어떻게 제한하지?\r\n\r\n모바일 기기의 접근을 제한하기 위해서는 우선 접근한 기기가 모바일인지, PC인지를 판단할 필요가 있었습니다. 이를 어떻게 구분할 수 있을지 다양한 방법을 찾아봤습니다.\r\n\r\n### 방식 1: userAgent\r\n\r\nMDN의 userAgent에 대한 설명을 참고하자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> [**MDN - userAgent**](https://developer.mozilla.org/ko/docs/Glossary/User_agent)\r\n>\r\n> 사용자 에이전트(user agent)는 사용자를 대표하는 컴퓨터 프로그램으로, [웹](https://developer.mozilla.org/ko/docs/Glossary/World_Wide_Web) 맥락에선 [브라우저](https://developer.mozilla.org/ko/docs/Glossary/Browser)를 의미합니다. … 브라우저는 서버에 보내는 모든 요청에 사용자 에이전트(UA) 문자열이라고 부르는, 자신의 정체를 알리는 [`User-Agent` (en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent) [HTTP](https://developer.mozilla.org/ko/docs/Glossary/HTTP) 헤더를 보냅니다. 이 문자열은 보통 브라우저 종류, 버전 번호, 호스트 운영체제를 포함합니다.\r\n\r\n<br/>\r\n\r\n![](userAgentConsole.png)\r\n\r\n<br/>\r\n\r\n`userAgent`의 값은 쉽게 확인할 수 있습니다. 현재 브라우저의 console에서 `navigator.userAgent`로 접근하여 확인이 가능합니다. `userAgent`로 확인이 가능한 각각의 값은 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nuserAgent = appCodeName/appVersion number (Platform; Security; OS-or-CPU;\r\nLocalization; rv: revision-version-number) product/productSub\r\nApplication-Name Application-Name-version\r\n```\r\n\r\n<br/>\r\n\r\n여기에서 `Platform`과 `OS` 등을 확인해 충분히 모바일 환경인지를 파악할 수 있습니다. 특정 문자열이 `userAgent` 값에 포함이 되어있는지의 여부를 바탕으로 아래와 같이 간단하게 판단이 가능합니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nif (/Android|iPhone/i.test(navigator.userAgent)) {\r\n  console.log(\"모바일 환경입니다.\")\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n다만, MDN에서도 `userAgent`를 활용하여 접근 기기를 판단하는 방식을 권장하고 있지 않습니다.\r\n\r\n<br/>\r\n\r\n> ⚠️ Browser identification based on detecting the user agent string is **unreliable** and **is not recommended**, as the user agent string is user configurable.\r\n\r\n<br/>\r\n\r\n이에 대한 예시로 Firefox나 Opera와 같은 브라우저에서는 해당 값을 사용자의 의도에 따라 자유롭게 변경이 가능한 경우도 있습니다. 단편적인 예시로 모바일 브라우저가 있겠습니다.\r\n\r\n<br/>\r\n\r\n![](userAgentMobile.png)\r\n\r\n<br/>\r\n\r\n현재 접속한 페이지는 로드될 때 `console.log(window.navigator.userAgent)`를 실행하도록 하였습니다. 좌측은 단순히 특정 페이지를 모바일 크롬 브라우저로 접속했을 때에 해당합니다. `Platform`에서 볼 수 있듯이 `iPhone`으로 모바일인지 판단이 가능합니다. 다만, 브라우저 옵션에서 데스크톱 화면으로 보기 기능을 활성화한 경우에는 문제가 발생합니다.\r\n\r\n<br/>\r\n\r\n우측을 해당 기능을 활성화한 상태에서 접근하면 `Macintosh`로 `Platform`이 잡히는 것을 볼 수 있습니다. 너무나도 쉽게 클라이언트 혹은 사용자가 변조할 수 있기 때문에 `userAgent`로 사용자의 기기를 판단하는 것은 그리 좋은 방식은 아니라 판단하였습니다.\r\n\r\n<br/>\r\n\r\n> **UA Spoofing**\r\n>\r\n> 위에서 언급한 `userAgent`를 조작하는 행위를 UA 스푸핑이라 칭합니다. 실제 브라우저 정보를 숨기는 방식으로 보안을 강화하거나 개발 과정에서 테스트를 위해서 이를 사용하는 경우가 있습니다.\r\n\r\n<br/>\r\n\r\n또한 실질적으로 `userAgent`의 점진적 삭제가 진행되었습니다. OS 이름과 버전, 브라우저 이름과 버전을 담고 있기 때문에 개인 정보 보안을 강화하기 위해 이러한 정책이 시작되었습니다.\r\n\r\n<br/>\r\n\r\n> **[Chrome 100의 지원 중단 및 삭제  |  Blog  |  Chrome for Developers](https://developer.chrome.com/blog/deps-rems-100?hl=ko)**\r\n\r\n### 방식 2: Client Hint\r\n\r\n개인정보 침해 문제가 있을 수 있는 `userAgent`를 대신하여 Chrome에서 제시하는 새로운 샌드박스 프로젝트 중 하나인 `Client Hint`가 있습니다. `userAgent`와는 다르게 상세한 정보를 제공하는 방식이 아닌 필요한 정보만 선택적으로 요청하고 제공할 수 있습니다.\r\n\r\n<br/>\r\n\r\n> **[Client hints(클라이언트 힌트) - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Client_hints)**\r\n\r\n<br/>\r\n\r\n`https` 환경에서만 지원하며, `userAgent`와는 다르게 `Accept-CH`를 선언해주는 것으로 적용할 수 있습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n<meta\r\n  http-equiv=\"Accept-CH\"\r\n  content=\"DPR, Width, Viewport-Width, Downlink ...\"\r\n/>\r\n```\r\n\r\n<br/>\r\n\r\n`content`에 특정 값들을 추가하여 요청할 사용자의 정보를 정의할 수 있습니다. 일부 속성들에 대해 간단하게 정리하자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> **Client Hint의 속성들**\r\n>\r\n> - `device-memory`: 디바이스의 사용 가능 메모리 (시스템 RAM과는 다름)\r\n> - `dpr`: device pixel ratio\r\n> - `width`: 이미지일 경우의 viewport 상에서 DRP가 적용된 px width\r\n> - `viewport-width`: css px 단위의 viewport width\r\n> - `rtt`: round-trip time\r\n> - `Downlink`: 추정 다운로드 속도\r\n> - `ect`: 추정 connection type\r\n\r\n<br/>\r\n\r\n여기서 모바일임을 판단할 수 있는 다양한 척도 중 하나는 `dpr`이라 생각했습니다.\r\n\r\n<br/>\r\n\r\n> **DPR란?**\r\n>\r\n> `dpr`은 `Device Pixel Ratio`의 줄임말로, 브라우저 상에서의 단일 픽셀을 그리는 데 물리적인 픽셀이 몇 개가 필요한지에 대한 값을 의미합니다.\r\n\r\n<br/>\r\n\r\n일반적으로 모바일 장치는 2 혹은 3 이상의 높은 DPR 값을 가지게 됩니다. 과거에 비해 유사한 화면 크기를 유지하며 해상도가 높아졌기 때문에 픽셀 밀도가 높아졌기 때문에 이러한 차이가 생기게 됩니다. 일반적인 PC 모니터의 경우는 대부분 DPR이 1에 해당하기 때문에 이러한 값을 기준으로 모바일인지를 판단할 수 있을 것이라 생각하였습니다.\r\n\r\n<br/>\r\n\r\n> **여담**\r\n>\r\n> 애플 제품군에서 쉽게 볼 수 있는 Renita 디스플레이는 픽셀 밀도가 2배 이상 되는 디스플레이를 의미합니다.\r\n>\r\n> [HD & Retina Display Media Queries](https://medium.com/@micjamking/hd-retina-display-media-queries-b5562b5430d6)\r\n\r\n<br/>\r\n\r\n![](canIUse.png)\r\n\r\n<br/>\r\n\r\n다만, `Client Hint`는 아직 모든 브라우저에서 지원하지는 않습니다. `Can i use`를 통해 확인해본 `Client Hint`는 아직 Safari와 Firefox 브라우저에서는 지원하지 않습니다. 만약 서비스가 IE까지 지원할 필요가 있는 경우라면 더더욱 사용이 힘들 것이라 생각되었습니다.\r\n\r\n<br/>\r\n\r\n> [User-Agent Client Hints](https://wicg.github.io/ua-client-hints/)\r\n\r\n<br/>\r\n\r\n또한 아직까지 `Client Hint`는 W3C(World Wide Web Consortium)로부터 아직 인정받은 표준은 아닌 것으로 파악하였습니다. 이러한 점을 고려하여 다른 방식으로 접근 기기를 판단하기로 하였습니다.\r\n\r\n### 방식 3: Modernizr\r\n\r\n모바일 기기와 PC를 구분짓는 가장 큰 차이점이 하나 존재했는데 이를 망각하고 있었습니다. 바로 `touchEvent`입니다. 일반적으로 요즘 모바일 기기는 터치 스크린이 존재하기 때문에 터치 이벤트를 지원하는지를 파악하여 모바일 기기인지 아닌지를 판단할 수 있습니다. 이를 단순히 구현하자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nconsole.log(navigator.maxTouchPoints) // 최대 터치 포인트 수 확인\r\nconsole.log(\"ontouchstart\" in document.documentElement) // 터치 이벤트 지원 여부 확인\r\n```\r\n\r\n<br/>\r\n\r\n![](console1.png)\r\n\r\n<br/>\r\n\r\n위 코드를 PC 환경에서 실행했을 경우에는 다음과 같은 출력값을 보여줍니다. 그렇다면 해당 코드로 간단하게 모바일임을 판단할 수 있을까요?\r\n\r\n<br/>\r\n\r\n![](console2.png)\r\n\r\n<br/>\r\n\r\n동일한 PC 브라우저이지만 모바일 뷰로 확인했을 경우에는 이전과 달리 터치 이벤트를 지원하는 것처럼 값이 출력됨을 확인할 수 있습니다. 이러한 점을 고려했을 때, 해당 코드만으로 터치 이벤트를 판단하는 것은 모바일 기기를 완전히 구분하기에는 힘들 수 있겠다는 생각이 들었습니다.\r\n\r\n<br/>\r\n\r\n또한 일부 최신 노트북의 경우, 터치 스크린을 가지고 있는 경우도 있어, 이러한 기기까지 모바일로 판단할 수도 있겠습니다. 그렇다면 하나의 요소만으로 모바일을 판단하는 것보다는 지금까지 고려했던 다양한 요소들을 종합적으로 판단하여 모바일인지를 확인하는 것이 합리적일 것 같습니다.\r\n\r\n<br/>\r\n\r\n다만, 이러한 요소들을 하나씩 브라우저에 맞추어 판단할 수 있는 코드를 작성한다면 모바일 기기임을 판단하는 코드를 작성하는데 많은 시간이 소요될 것입니다. 이러한 점을 고려하여 저희 프로젝트에서는 `Modernizr`를 도입하는 것을 고려하였습니다.\r\n\r\n## Modernizr 적용기\r\n\r\n`Modernizr`는 어떤 CSS3와 HTML5 기능들을 사용할 수 있는지를 쉽게 테스트할 수 있는 라이브러리입니다. 원하는 이벤트 혹은 기능들만을 선택해 해당 기능들을 현재 환경에서 지원하는지를 테스트할 수 있어 이를 바탕으로 모바일임을 판단할 수 있을 것이라 생각하여 `Modernizr` 적용을 시도하였습니다.\r\n\r\n<br/>\r\n\r\n다만, 현재로서는 다양한 기능들을 고려하여 모바일 환경인지를 판단하는 기준이 명확하지 않아 우선 터치 이벤트만을 판단하는 방식으로 `Modernizr`를 적용하였습니다. 이후 추가적인 기능들을 테스트하여 모바일 기기 판단의 정확도를 높일 수 있을 것이라 생각합니다.\r\n\r\n### Modernizr 파일 생성하기\r\n\r\n> **[Modernizr Download Builder](https://modernizr.com/download?setclasses)**\r\n\r\n<br/>\r\n\r\n`Modernizr`를 적용하기 위해 상단 링크를 통해 `Modernizr` 파일을 다운받을 수 있습니다. `Modernizr`를 이용해 체크하고 싶은 요소들을 체크하여 `modernizr-custom.js`파일을 빌드합니다.\r\n\r\n<br/>\r\n\r\n![](modernizr1.png)\r\n\r\n![](modernizr2.png)\r\n\r\n해당 파일을 다운로드하여 프로젝트에 위치 시킵니다.\r\n\r\n### Modernizr 적용하기\r\n\r\n파일의 위치는 크게 상관없으나, 저희 프로젝트에 적용하는 과정에서는 `src`폴더 하위에 위치시켰습니다. (React, Vite 프로젝트입니다.) 전역으로 어디에서나 `Modernizr`를 사용하기 위해 `index.html`에 `script` 태그를 이용하여 추가한 파일을 불러옵니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n<script type=\"text/javascript\" src=\"/src/modernizr.js\"></script>\r\n```\r\n\r\n<br/>\r\n\r\n전역으로 적용한 이후에는 `Modernizr`를 사용하고 싶은 파일에서 아래와 같이 활용이 가능합니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nconsole.log(Modernizr.touchevents) // 터치 이벤트 지원 유무 true/false\r\n```\r\n\r\n<br/>\r\n\r\n현재 프로젝트에서는 강의 생성과 관련된 기능들을 모바일 기기에서는 제한하고자 하였습니다. 이를 이용하여 아래와 같이 작동하도록 작업하였습니다. 현재는 단순히 터치 이벤트를 기준으로 판단하였기 때문에 모바일 뷰에서 페이지를 로드했을 경우에 ‘새로운 강의 생성하기’ 카드가 제거되는 모습을 볼 수 있습니다.\r\n\r\n<br/>\r\n\r\n![](result.gif)\r\n\r\n### 번외) Modernizr type 설정하기\r\n\r\n현 프로젝트에서 `TypeScript`를 사용하고 있기 때문에 `Modernizr`에 대한 type을 지정해줄 필요가 있습니다. type을 지정해주기 위한 `modernizr.d.ts`를 새로 생성하여 아래와 같이 type을 지정해주었습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\ndeclare global {\r\n  interface ModernizrStatic {\r\n    touchevents: boolean;\r\n  }\r\n  let Modernizr: ModernizrStatic;\r\n}\r\n\r\nexport {};\r\n```\r\n\r\n<br/>\r\n\r\n이를 적용하기 위해 `tsconfig.json`에 다음을 추가하여 type 지정을 완료하였습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n\"include\": [\"src/**/*\", \"src/global.d.ts\"],\r\n```\r\n\r\n## 포스팅을 마치며\r\n\r\n모바일 기기일 경우에 특정 기능을 제한하고 싶다는 생각부터 시작해 다양한 개념들을 학습할 수 있었습니다. 현재 적용한 `Modernizr`는 가장 기초적인 형태이기 때문에 이를 고도화한다면 더 많은 기기에서 다양한 기능들에 대해 대응이 가능할 것 같습니다.\r\n\r\n<br/>\r\n\r\n부족한 글 읽어주셔서 감사드립니다. 혹여나 틀린 부분이 있다면 지적해주시면 감사드리겠습니다.\r\n\r\n### 참고 자료\r\n\r\n- **[UA 대신에 Client Hints 사용해보기](https://frontdev.tistory.com/entry/UA-%EB%8C%80%EC%8B%A0%EC%97%90-Client-Hints-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0)**\r\n- [**MDN(KR)-Client Hint**](https://developer.mozilla.org/ko/docs/Web/HTTP/Client_hints)\r\n- **[Chrome 100-User Agent 지원 중단 예정](https://developer.chrome.com/blog/deps-rems-100?hl=ko)**\r\n- [**MDN(KR)-User Agent**](https://developer.mozilla.org/ko/docs/Glossary/User_agent)\r\n- **[MDN(US)-User Agent](https://developer.mozilla.org/en-US/docs/Glossary/User_agent)**\r\n- **[Naver D2-User-Agent Client Hints의 도입](https://d2.naver.com/helloworld/6532276)**\r\n- **[Modernizr](https://modernizr.com/download?setclasses)**\r\n"},{"id":"88b51a0c-fecb-5b8b-837b-944fd6a0f391","frontmatter":{"title":"[Boarlog] 프론트엔드 배포 삽질하기(feat. Netlify)","icon":"TbCloudUp","date":"November 25, 2023"},"fields":{"slug":"/boarlog/fe-deploy/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n## 신나는 배포 시작\r\n\r\nFE 공통 개발 환경 설정 이후에 우리가 의도한 방식으로 잘 동작하는지를 확인하기 위해 가장 간단한 페이지 중 하나인 `Login` 페이지만 UI를 구성해보고자 하였습니다. component를 어떤 단위로 어떻게 구분해야 할지 기준이 명확하지 않았기에 우선 공용 component를 고려하지 않고 해당 페이지에서 간단히 작업을 시작하였습니다.\r\n\r\n<br/>\r\n\r\n작업 이후 이를 팀원들 혹은 타인에게 공유시에 로컬에서 빌드해 결과물을 공유하는 방식보다는 실제로 서비스를 중간중간 배포하여 그 결과를 확인하고 공유하는 방향이 더 효과적일 것이라 생각해 배포를 시도하였습니다.\r\n\r\n### CI/CD란?\r\n\r\n배포를 고려하는 단계에서 가장 처음 접한 단어입니다. 많이는 들어봤지만 Ci/CD가 정확히 어떤 것을 의미하는지, CI/CD 파이프라인을 구성한다는 것이 어떠한 의미인지는 알지 못해 이에 대해 알아보겠습니다.\r\n\r\n<br/>\r\n\r\n> **CI? CD?**\r\n>\r\n> - `CI` : Continuous Intergration\r\n> - `CD` : Continuous Delivery/Continuous Deploy\r\n\r\n<br/>\r\n\r\n`CI`는 해석하자면 **지속적 통합**을 의미하며, Build와 Test를 실시하는 프로세스를 상시로 수행하는 것을 의미합니다. `CD`는 **지속적 배포**를 의미하며, 이 둘을 합치면 아래와 같은 의미를 가지게 됩니다.\r\n\r\n<br/>\r\n\r\n> **짧은 주기로 개발중인 소프트웨어를 배포하고 그 과정을 자동화 하겠다.**\r\n\r\n<br/>\r\n\r\n이러한 CI/CD를 우리 프로젝트에 어떻게, 어떤 것들을 이용하여 도입할 수 있을지가 새로운 고민이었습니다. BE 팀의 경우, Github Action과 Docker를 이용하여 `frontend` directory를 제외한 나머지에서 변경 사항이 발생했을 경우에 컨테이너를 구성하여 이를 배포하도록 구성하였습니다.\r\n\r\n<br/>\r\n\r\n다만, 현재 FE 담당 팀원들은 Docker를 사용해본 경험이 없을 뿐더러 배포에 익숙하지 않았기에 간단하게 배포를 진행하고 이후에 이를 시도해보기로 결정하였습니다.\r\n\r\n<br/>\r\n\r\n> **CI/CD와 관련한 글은 [여기](https://techblog.woowahan.com/2579/)를 참고했습니다.**\r\n\r\n## 그래서 우리는 어떤 것을 도입하기로 하였는가?\r\n\r\n한정된 6주라는 시간에 프로젝트를 완성해야 하기에 자동화할 수 있는 작업들은 자동화하는 편이 좋겠다는 생각이 들었습니다. 매번 배포를 진행하는 방식보다는 변경 사항을 push했을 경우에 자동 배포가 되도록 구성하는 것이 목표였습니다.\r\n\r\n<br/>\r\n\r\n배포 과정이 간단하면서도 가격 부담도 크지 않거나 거의 없고, 자동 배포가 되도록 할 수 있는 방법이라면 바로 떠오르는 것은 `Cloudflare Pages`와 `Netlify`였습니다. 우선 상대적으로 한 달에 가능한 build 수가 더 많은 `Cloudflare`를 활용하기로 결정하였습니다.\r\n\r\n### 가격 정책이 궁금하다면?\r\n\r\n2023년 11월 16일 기준으로 `Cloudflare Pages`와 `Netlify`의 무료 플랜에서 제공하는 기능은 아래와 같습니다. 상대적으로 build 횟수가 200개는 더 많고, 대역폭 제한도 없는 `Cloudflare`가 더 매력적으로 다가와 `Cloudflare`를 선택하였습니다.\r\n\r\n<br/>\r\n\r\n![Cloudflare pages 가격 정책](cloudflare.png)\r\n\r\n![Netlify 가격 정책](netlify.png)\r\n\r\n## Cloudflare 배포 시도\r\n\r\n### 배포가 왜… 안되는거지…?\r\n\r\n우선 github repository를 cloudflare Pages에서 불러와 아래와 같이 설정값을 입력하여 배포를 시도하였습니다. `Vite`는 따로 없었기에 설정하지 않았고, 빌드 명령어와 더불어 `NODE_VERSION`을 환경 변수로 추가하였습니다.\r\n\r\n<br/>\r\n\r\n![](cloudflareVariable.png)\r\n\r\n<br/>\r\n\r\n![](cloudflareBuild.png)\r\n\r\n<br/>\r\n\r\n빌드 과정에서 에러가 발생하여 어떤 에러인지부터 살펴보았습니다.\r\n\r\n### 원인 분석/문제 해결 시도\r\n\r\n```arduino\r\n23:04:20.301\tInstalling project dependencies: npm clean-install --progress=false\r\n23:04:22.689\tnpm ERR! code EUSAGE\r\n23:04:22.698\tnpm ERR!\r\n23:04:22.698\tnpm ERR! `npm ci` can only install packages when your package.json and package-lock.json or npm-shrinkwrap.json are in sync. Please update your lock file with `npm install` before continuing.\r\n23:04:22.698\tnpm ERR!\r\n23:04:22.699\tnpm ERR! Missing: eslint-plugin-import@2.29.0 from lock file\r\n...\r\n23:04:22.710\tnpm ERR! Run \"npm help ci\" for more info\r\n23:04:22.710\r\n23:04:22.711\tnpm ERR! A complete log of this run can be found in: /opt/buildhome/.npm/_logs/2023-11-15T14_04_21_033Z-debug-0.log\r\n23:04:22.719\tError: Exit with error code: 1\r\n23:04:22.719\t    at ChildProcess.<anonymous> (/snapshot/dist/run-build.js)\r\n23:04:22.720\t    at Object.onceWrapper (node:events:652:26)\r\n23:04:22.720\t    at ChildProcess.emit (node:events:537:28)\r\n23:04:22.720\t    at ChildProcess._handle.onexit (node:internal/child_process:291:12)\r\n23:04:22.730\tFailed: build command exited with code: 1\r\n23:04:23.653\tFailed: error occurred while running build command\r\n```\r\n\r\n<br/>\r\n\r\n배포 과정에서 남겨진 로그를 살펴보니 이 부분이 눈에 들어왔습니다.\r\n\r\n<br/>\r\n\r\n```arduino\r\nnpm ERR! `npm ci` can only install packages when your package.json and package-lock.json or npm-shrinkwrap.json are in sync. Please update your lock file with `npm install` before continuing.\r\n```\r\n\r\n<br/>\r\n\r\n`package.json`과 `package-lock.json`이 서로 동기화되지 않아 발생하는 문제라 추정되었습니다. 관련하여 여러 글들을 바탕으로 하나씩 시도해보았습니다.\r\n\r\n### 다양하게 시도한 해결 방법들\r\n\r\n우선 `package.json`과 `package-lock.json`이 서로 동기화되지 않았으므로, `package-lock.json`에 문제가 있다 판단하였습니다. `node_modules`와 `package-lock.json`을 제거하고 다시 `npm install`을 진행한 후에 이를 push하여 배포를 시도해봤습니다.\r\n\r\n<br/>\r\n\r\n> **✖️ 하지만 해결하지 못했습니다.**\r\n\r\n<br/>\r\n\r\n여전히 동일한 문제가 발생하여 우선 배포 과정에서 입력되는 `npm ci`가 로컬에서 잘 작동하는지를 확인하였습니다. 이 또한 문제없이 작동하여 로컬에서 아래 command를 이용해 빌드를 시도해보고, 이를 확인하였습니다.\r\n\r\n<br/>\r\n\r\n```arduino\r\n$ npm run build\r\n$ npm run preview\r\n```\r\n\r\n<br/>\r\n\r\n> **✖️ 이 또한 문제가 없었습니다.**\r\n\r\n<br/>\r\n\r\n혹여나 라이브러리간에 버전이 맞지 않아 종속성 문제로 배포가 불가능한지 의심이 들어 다음도 시도하였습니다. `force`는 충돌을 우회하여 install을 진행하며, `legacy-peer-deps`는 peer 종속성을 완전히 무시할 수 있는 옵션에 해당합니다.\r\n\r\n<br/>\r\n\r\n```arduino\r\n$ npm install --force\r\n$ npm install --legacy-peer-deps\r\n```\r\n\r\n<br/>\r\n\r\n> **✖️ 이 또한 문제가 없었습니다.**\r\n\r\n<br/>\r\n\r\n혹시나 하는 마음에 node 버전을 다양하게 변경하였습니다. 제가 사용하는 로컬 node 버전은 `20.4.0`이기에 너무 높은 버전이라 발생하는 문제일 수도 있겠다는 생각에 `18.0.0`으로 낮추어 시도해보았지만, 이 역시 문제를 해결할 수는 없었습니다.\r\n\r\n<br/>\r\n\r\n> **혹여나 동일한 문제를 겪고 계실 분들을 위해**\r\n>\r\n> 다양한 방식을 시도해보았지만 정답을 찾지는 못하였습니다. 이 과정에서 참고한 자료들을 공유드립니다.\r\n>\r\n> - [I cannot deploy my website](https://community.cloudflare.com/t/i-cannot-deploy-my-website/536564)\r\n>\r\n> - [I tried to deploy my React App on Cloudflare. Building process fails & I get some Errors. The complete log is provided below](https://stackoverflow.com/questions/77009711/i-tried-to-deploy-my-react-app-on-cloudflare-building-process-fails-i-get-som)\r\n>\r\n> - [☁ Cloudflare로 Vite React 프로젝트 배포 ☁](https://velog.io/@leehyewon0531/Cloudflare로-Vite-React-프로젝트-배포)\r\n>\r\n> - [CloudFlare Pages 배포하면서 만난 에러들(feat : Vite, React, yarn)](https://velog.io/@bebrain/CloudFlare-Pages-배포하기)\r\n>\r\n> - [Vite](https://ko.vitejs.dev/guide/static-deploy.html)\r\n\r\n## 돌고 돌아 Netlify로\r\n\r\ncloudflare로 배포를 꼬박 하루 시도해보고, 다른 곳에서도 동일한 문제가 발생하는지 확인해보고자 2순위였던 `Netlify`에서 시도하였습니다. cloudflare에서 배포를 시도했을 때와 동일한 옵션으로 시도하였더니…\r\n\r\n<br/>\r\n\r\n![바로 성공… 했습니다.](netlifyBuild.png)\r\n\r\n<br/>\r\n\r\n너무나 허탈하게도 문제없이 배포가 잘 진행되었습니다. 다만, `Netlify`로 react 프로젝트를, 특히 `React Router`를 활용하여 라우팅을 하였다면 필요한 작업이 한 가지 있습니다.\r\n\r\n### \\_redirects 추가하기\r\n\r\n`Netlify`로 프로젝트를 배포한 이후, 즐거운 마음으로 배포된 페이지에 접속하고 라우팅이 잘 적용되었는지 확인하려고 `/login`에 직접 바로 접속하는 순간… `Page Not Found`가 표시되며 정상적으로 접속이 불가능했습니다.\r\n\r\n<br/>\r\n\r\n![](pageNotFound.png)\r\n\r\n<br/>\r\n\r\n이러한 이유는 `React Router`가 client 측에서 라우팅을 처리하기 때문이라고 합니다. 따라서 바로 특정 주소로 접근하게 되면 `Netlify`에서 이를 처리하지 못해 `Page Not Found`가 표시되게 됩니다. 이를 `_redirects` 파일을 추가해주는 것으로 해결할 수 있습니다.\r\n\r\n<br/>\r\n\r\n> **[Netlify docs: redirection](https://docs.netlify.com/routing/redirects/)**\r\n\r\n<br/>\r\n\r\n`/public` directory 하위에 `_redirects` 파일을 추가하고, 아래와 같이 텍스트를 작성하여 저장합니다. 해당 텍스트는 root 주소 뒤로 오는 모든 주소에 대해 root로 redirection함을 의미합니다.\r\n\r\n<br/>\r\n\r\n> **[관련 참고글](https://dev.to/rajeshroyal/page-not-found-error-on-netlify-reactjs-react-router-solved-43oa)**\r\n\r\n<br/>\r\n\r\n다음과 같이 작성하여 정상적으로 `Login` 페이지에 접근할 수 있었습니다.\r\n\r\n<br/>\r\n\r\n![](login.png)\r\n"},{"id":"484e44f1-03f8-5364-945c-b1a1404175fe","frontmatter":{"title":"놀러와요, 비동기의 숲","icon":"TbChristmasTree","date":"July 29, 2023"},"fields":{"slug":"/javascript/asynchronous-vs-synchronous/"},"rawMarkdownBody":"\r\n# 동기와 비동기, 새로운 벽\r\n\r\n![](giphy.gif)\r\n\r\n> 아름다운 동기와 비동기의 현 주소입니다.\r\n\r\n<br/>\r\n\r\n동기와 비동기에 대해 간단하게 들어왔지 이에 대한 깊은 이해를 해본 적은 없었습니다. 오늘은 구현보다 동기와 비동기가 과연 정확히 무엇이고, 어떻게 이를 사용하는지와 더불어 JavaScript에서는 어떻게 동작하는지까지 학습하는 것을 목표로 합니다.\r\n\r\n## 동기와 비동기 쉽게 뜯어보기\r\n\r\n우선 동기와 비동기가 무엇인지에 대해 알아보는 것으로 학습을 시작해보겠습니다. 우리가 아는 동기의 뜻은 무엇인가요? 동기는 **같은 시기 또는 같은 기간**이라는 의미를 가지고 있습니다. 비동기는 이에 반대되는 개념이 비동기일 것입니다. 프로그래밍에서의 동기와 비동기는 어떤 의미일까요?\r\n\r\n<br/>\r\n\r\n> **동기 - Synchronous | 동시에 일어나는**\r\n>\r\n> - 동시에 일어난다는 뜻을 가집니다.\r\n> - 어떤 것을 요청하면 이에 대한 결과가 동시에 일어난다는 뜻입니다.\r\n> - 요청을 한다면 얼마나 시간이 걸려도 그 자리에서 결과가 주어져야 합니다.\r\n> - 즉, **순차적**으로 진행된다는 의미입니다. 순서에 맞춰 진행합니다.\r\n\r\n<br/>\r\n\r\n> **비동기 - Asynchronous | 동시에 일어나지 않는**\r\n>\r\n> - 동시에 일어나지 않음을 의미합니다.\r\n> - 어떤 것에 대한 요청에 의한 결과가 동시에 일어나지 않음을 의미합니다.\r\n> - 요청해도 이를 즉시 처리하지 않아 결과가 이후에 나오게 됩니다.\r\n> - 즉, **여러 개의 요청을 동시에 처리**할 수 있다는 의미입니다.\r\n\r\n<br/>\r\n\r\n일상에서 쉽게 만나볼 수 있는 동기와 비동기의 예시를 살펴봅시다. 카페에서 공부하기를 좋아하는 컴퓨터공학과 학생 **`😹 고영희`**씨가 카페에 들어가 커피를 주문합니다.\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n> ☕ : 잠시만 여기서 기다려주세요. 바로 준비해드릴게요.\r\n\r\n<br/>\r\n\r\n어라? 여기서 서서 기다리라구요? 뒤에 사람들 많은데…\r\n\r\n<br/>\r\n\r\n커피를 **주문**하고 주문한 메뉴를 **받는 것**까지 기다리게 됩니다. 뒤에 줄을 서있는 사람들도 **순차적**으로 기다려가며 커피를 받아가겠죠. 이게 바로 동기의 예시라 할 수 있습니다. 그렇다면 우리가 아는 일반적인 카페는 어떤가요?\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n> ☕ : 준비되면 진동벨로 알려드릴게요.\r\n\r\n<br/>\r\n\r\n주문을 마친 고영희씨는 자리를 잡고 진동벨이 울릴때까지 기다립니다. 그 자리에서 메뉴를 바로 받지 않고 직원은 바로 다음 사람의 주문을 받겠죠. 이러한 방식으로 **여러 주문을 동시에 받아 처리**하는 것은 비동기의 예시라고 할 수 있습니다. 이렇게 봤을때는 비동기가 좋아보이지 않나요? 그럼 항상 비동기를 사용하면 좋겠네요! 근데 과연 그럴까요? 모든 것에는 장단점이 있기 마련입니다.\r\n\r\n<br/>\r\n\r\n동기 방식은 매우 직관적입니다. 어떤 작업을 실행하면 끝날때까지, 그리고 순차적으로 진행하기 때문입니다. 하지만, 결과가 주어질 때까지 아무것도 못하고 대기해야 합니다. 반대로 비동기 방식은 결과가 주어지기 전까지 다른 작업을 할 수 있기 때문에 효율적입니다. 하지만 동기 방식에 비해 직관적이지 못하고 복잡하다는 단점이 있습니다.\r\n\r\n## 개발에서의 동기와 비동기\r\n\r\n![https://adrianmejia.com/asynchronous-vs-synchronous-handling-concurrency-in-javascript/](asynchronousVsSynchronous.png)\r\n\r\n자, 그러면 개발에서의 동기와 비동기에 대해 알아봅시다.\r\n\r\n<br/>\r\n\r\n위 차트는 동기와 비동기의 차이점을 한 눈에 알아볼 수 있습니다. **왼쪽이 비동기, 오른쪽이 동기**에 해당합니다. 동기와 비동기를 각각 한 단어로 간단히 표현하자면, 동기는 ‘직렬적’, 비동기는 ‘병렬적’으로 작동하는 방식이라 할 수 있습니다.\r\n\r\n![https://poiemaweb.com/es6-promise](es6Synchronous.png)\r\n\r\n![https://poiemaweb.com/es6-promise](es6Asynchronous.png)\r\n\r\n여기서 동기 모델을 살펴보면, `Blocking`을 확인할 수 있습니다. 카페에서 앞 손님이 주문을 마치고 메뉴를 받아가는 시점까지 아무것도 하지 못하는 상황, 다시 말해 동기적인 작업에 따라 이후 작업이 막히게 된 것입니다. 이를 `Blocking`이라 표현합니다. 반대로 작업이 막히지 않으면 `Non-blocking`이라 합니다.\r\n\r\n<br/>\r\n\r\n그렇다면 동기는 `Blocking`이고, 비동기는 `Non-Blocking`일까요? 이 둘은 비슷할 것 같지만 엄연히 다른 개념입니다.\r\n\r\n## Blocking, Non-blocking\r\n\r\n![https://developer.ibm.com/articles/l-async/](blockingNonBlocking.png)\r\n\r\n동기와 비동기에 대한 각 뜻은 이해했는데, 그렇다면 `blocking`과 `non-blocking`은 도대체 무엇이고, 어떤 차이가 있기에 **엄연히 다른 개념**이라 칭하였을까요? 동기와 비동기는 **직렬과 병렬**처리로 구분하였습니다. `blocking`과 `non-blocking`은 **제어**에서 그 차이가 있습니다.\r\n\r\n<br/>\r\n\r\n> **Blocking**\r\n>\r\n> - 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 것입니다.\r\n> - 사전적인 정의로는 **막혀버린, 제한된, 대기하는** 상태를 의미합니다.\r\n> - 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 돌려주지 않는 경우에 해당합니다.\r\n\r\n<br/>\r\n\r\n> **Non-Blocking**\r\n>\r\n> - 직접 제어할 수 없는 대상의 작업 처리 여부와 상관이 없습니다.\r\n> - Blocking과는 반대되는 개념입니다.\r\n> - 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 건내주는 경우에 해당합니다.\r\n\r\n<br/>\r\n\r\n이러한 `Blocking`과 `Non-blocking`은 동기와 비동기에 따라 정해지는 개념이 아닙니다. 동기이면서 `Blocking`일 수도 있으며, `Non-blocking`일 수도 있습니다. 각각이 어떤 경우인지 살펴보겠습니다.\r\n\r\n### Sync + Blocking / Async + Non-blocking\r\n\r\n이 경우는 우리가 앞에서 살펴본 예시와 동일합니다. 각각을 정리하면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> Sync : 직렬적으로 진행합니다.\r\n>\r\n> Blocking : 제어권을 넘겨주지 않습니다.\r\n\r\n<br/>\r\n\r\n이에 대한 예시를 들어봅시다.\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n>\r\n> ☕ : 메뉴 나올때까지 여기 서서 기다려주세요.\r\n>\r\n> 😹 : (메뉴 만드는게 궁금해서 지켜봄)\r\n>\r\n> ☕ : A-18번 고객님, 주문하신 메뉴 준비되었습니다.\r\n>\r\n> 😹 : 네! (신나는 마음으로 바로 들고감)\r\n\r\n<br/>\r\n\r\n그렇다면 반대의 경우는 어떨까요?\r\n\r\n<br/>\r\n\r\n> Async : 병렬적으로 진행합니다.\r\n>\r\n> Non-blocking : 제어권을 넘겨줍니다.\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n>\r\n> ☕ : 진동벨로 알려드릴게요.\r\n>\r\n> 😹 : (자리 잡아서 노트북 꺼내고 친구랑 카톡 중)\r\n>\r\n> ☕ : (지이이잉— 지이이잉—)\r\n>\r\n> 😹 : (벌떡 일어나서 신나는 마음으로 커피 가지러 감)\r\n\r\n<br/>\r\n\r\n그렇다면 나머지 경우들은 어떨까요?\r\n\r\n### Sync + Non-blocking / Async + Blocking\r\n\r\n우선 동기적이면서 Non-blocking인 경우를 살펴보겠습니다.\r\n\r\n<br/>\r\n\r\n> Sync : 직렬적으로 진행합니다.\r\n>\r\n> Non-blocking : 제어권을 넘겨줍니다.\r\n\r\n<br/>\r\n\r\n이 경우에는 호출되는 함수는 결과를 처리하는대로 반환하고, 호출하는 함수는 작업 완료 여부를 계속 주시하는 형태로 이루어집니다. 예시를 통해 살펴봅시다.\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n>\r\n> ☕ : 앉아서 기다려주세요.\r\n>\r\n> 😹 : 제꺼 나왔나요?\r\n>\r\n> ☕ : 아니요…\r\n>\r\n> 😹 : 제꺼 나왔나요?\r\n>\r\n> ☕ : 아니요…!!\r\n>\r\n> 😹 : 제꺼 나왔나요?\r\n>\r\n> ☕ : 아니요…!!!!!\r\n>\r\n> ...\r\n\r\n<br/>\r\n\r\n반대의 경우는 어떨까요?\r\n\r\n<br/>\r\n\r\n> Async : 병렬적으로 진행합니다.\r\n>\r\n> Blocking : 제어권을 넘겨주지 않습니다.\r\n\r\n<br/>\r\n\r\n이 경우에는 호출되는 함수의 결과에 관심은 없지만 호출하는 함수는 이 결과를 계속 기다리는 형태입니다. 예시를 통해 살펴봅시다.\r\n\r\n<br/>\r\n\r\n> 😹 : 아이스아메리카노 1잔하고, 티라미수 하나 주세요.\r\n>\r\n> ☕ : 메뉴 나올때까지 여기 서서 기다려주세요.\r\n>\r\n> 😹 : (메뉴 나왔는지 관심도 없음. 그냥 서서 넷플릭스 시청중)\r\n\r\n<br/>\r\n\r\n> 이에 대한 내용은 아래 영상을 참고해보시면 더 큰 도움이 될 것 같습니다.\r\n>\r\n> [[10분 테코톡] 🐰 멍토의 Blocking vs Non-Blocking, Sync vs Async](https://www.youtube.com/watch?v=oEIoqGd-Sns)\r\n\r\n# 참고\r\n\r\n- https://dev-coco.tistory.com/46\r\n- https://velog.io/@maketheworldwise/SyncAsync-BlockingNon-Blocking-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EC%9D%BC%EA%B9%8C\r\n- https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx\r\n- https://musma.github.io/2019/04/17/blocking-and-synchronous.html\r\n- https://ljtaek2.tistory.com/142\r\n- https://velog.io/@gil0127/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-asynchronous\r\n"},{"id":"60663494-5e4b-5633-b38b-3adcf0c9cef5","frontmatter":{"title":"부스트캠프 웹・모바일 8기 챌린지 수료 회고","icon":"TbMedal","date":"August 05, 2023"},"fields":{"slug":"/boostcamp/challenge-end/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 챌린지 활동과 관련된 내용을 담고 있습니다.\r\n\r\n<br/>\r\n\r\n![](picture.png)\r\n\r\n<br/>\r\n\r\n> 함께 성장의 가치를 알 수 있도록 도와주신 **성인님, 영빈님, 호선님, 진혁님, 준수님, 지예님, 민규님, 영우님, 재현님, 상원님, 진성님, 민님, 현우님, 지은님, 용현님, 정민님, 현우님, 검기님**께 감사의 말씀을 전합니다.\r\n>\r\n> 다른 캠퍼분들에게도 감사 인사 드립니다.\r\n\r\n# 해치웠나?\r\n\r\n![챌린지를 이겨냈음을 기뻐하는 제 상태입니다.](cat.png)\r\n\r\n정말 많은 일들로 가득했던 4주간의 챌린지 활동이 드디어 막을 내렸습니다. 챌린지 과정에서 어떤 것을 학습했고, 어떤 부분이 성장했는지를 공유드리고자 합니다.\r\n\r\n# 3번 죽었다 살아났습니다.\r\n\r\n챌린지 기간동안 3번의 실패를 경험했습니다. 정말 아스팔트 바닥에 얼굴부터 넘어졌던 경험이라, 각 실패 과정에서 어떤 점들을 느꼈고 이겨낼 수 있었는지에 대해 적어볼까 합니다.\r\n\r\n## 나는 말하는 감자\r\n\r\n무려 1주차부터 벽을 느꼈습니다. 처음 보는 개념에 처음 보는 라이브러리에... 어디서부터 손을 대야 할지 도무지 모르겠는 상황을 마주했습니다.\r\n\r\n<br/>\r\n\r\n> ❓ 이게 도대체 뭐지?\r\n>\r\n> ❓ 어디서부터 시작하지?\r\n>\r\n> ❓ 어떻게 작성하지?\r\n>\r\n> ❓ 어떤 개념을 공부하지?\r\n\r\n<br/>\r\n\r\n고민과 생각이 꼬리에 꼬리를 물고 길어지기만 했습니다. 결국 정말 기본적인 기능만 구현을 완료한 상태로 하루를 마무리했습니다. 생각이 많아지는 하루였습니다.\r\n\r\n<br/>\r\n\r\n> **'1주차부터 이렇게 힘든데 내가 4주차까지 이 과정을 버틸 수 있을까?'**\r\n>\r\n> **'이건 내 길이 아닌건가?'**\r\n\r\n<br/>\r\n\r\n챌린지 과정을 수료한 시점에서 바라보자면 정말 의미가 없는 고민들이지만, 그 당시에는 정말 큰 고민이었습니다. 그 당시에 작성했던 회고록이 큰 도움이 되었습니다. 절망감과 자괴감 같은 감정을 배제하고 객관적으로 현 상황을 바라보며 **앞으로 이러한 일을 동일하게 마주했을 때, 어떻게 이겨낼 수 있을지**에 대한 고민을 시작했습니다.\r\n\r\n<br/>\r\n\r\n이러한 고민들을 바탕으로 나만의 규칙을 정했습니다. 전부 지키지는 못했지만, 일부 규칙들은 정말 많은 도움이 되었습니다.\r\n\r\n<br/>\r\n\r\n> **하루를 알차게 보내는 규칙**\r\n>\r\n> - 개념 혹은 과제 어느 한 쪽에 너무 집중하지 말자.\r\n> - 과제와 관련된 개념을 간단히 1~2시간 정도 공부하자.\r\n> - 과제는 특정 시간이 되면 잠시 내려놓자.\r\n> - 과제도 중요하지만 개념도 중요하다. 개념 정리는 꼼꼼하게 하려고 노력해보자.\r\n> - 특정 시간을 주기로 삼아 주기적으로 진행도를 체크해보자. 길을 찾을 수 있는 나침반이 될 것이다.\r\n> - 정말 한 일이 없어도 새벽 2시에는 잠자리에 들자. 우리에게는 내일도 있다.\r\n> - 잠시 다른 캠퍼들도 둘러보자. 내가 하는 고민들에 대한 답을 찾을 수도 있다.\r\n\r\n<br/>\r\n\r\n> **하루를 아름답게 보내는 규칙**\r\n>\r\n> - 아무리 바빠도 2일에 한 번씩은 산책을 나가자. 많이도 아니고 30분만 걷자. 산책은 생각을 정리하는 훌륭한 도구다. 때로는 잡생각을 비워버릴 수 있는 기회이기도 하다.\r\n> - 다른 사람과 비교하지 말자. 잘하는 사람들은 그 실력 뒤에 노력한 시간이 존재할 것이다.\r\n> - 나만의 페이스와 기준을 찾자. 무조건 과제를 완벽하게 하는 것이 중요하지는 않다. 내 기준과 속도에 맞추어 차근차근 계단을 올라가는 것이 중요하다.\r\n> - 완벽함을 추구하는 것은 매우 위험하다. 완벽이라는 단어에 홀려 정작 중요한 일들을 신경쓰지 않았던 예전을 생각해보자.\r\n\r\n<br/>\r\n\r\n해당 규칙과 관련하여 고민한 과정은 [1주차 회고록](https://velog.io/@pexe99/2023-%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Web-Mobile-8%EA%B8%B0-1%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0)에서 확인하실 수 있습니다.\r\n\r\n## 나는 왜 저렇게 못하지?\r\n\r\n사실 첫 번째 실패를 이겨내는 과정에서 생각해보지 못한 부분이 있었습니다. 바로 **내가 실패를 마주하게 된 원인이 무엇인가?** 였습니다. 이를 두 번째 실패 과정에서 새로 깨닫게 되었습니다.\r\n\r\n<br/>\r\n\r\n> 다른 캠퍼들과 나를 비교하지 말자.\r\n\r\n<br/>\r\n\r\n상대방과의 비교는 좋은 동기부여가 될 수도 있지만 때로는 독이 될 수도 있습니다. 사실 상대방과 나 자신을 비교하는 것은 하지 말자고 생각해도 무의식중에 수없이 반복하고 있습니다. 당장 길거리로 나가 지나가는 사람들을 보는 것만으로도 이미 알게 모르게 비교를 하고 있을 것이라 생각합니다. (이 부분은 어디까지나 개인적인 생각입니다.)\r\n\r\n<br/>\r\n\r\n그렇기에 의식적으로 타인과의 비교가 아닌 **나 자신과의 비교**를 지속적으로 진행하는 것이 중요하다고 생각합니다.\r\n\r\n<br/>\r\n\r\n> **어제의 나와 오늘의 나를 비교하자**\r\n>\r\n> - 타인과의 과도한 비교는 스스로에게 독이 될 수 있다.\r\n> - 어제의 나와 오늘의 나에 대한 비교를 통해 스스로의 성장 과정을 객관화하자.\r\n> - 스스로에 대한 객관성을 길러 메타인지를 활성화하자.\r\n\r\n<br/>\r\n\r\n단순히 비교를 통한 감정 소모가 아닌 보다 발전한 스스로를 발견할 수 있도록, 그리고 이러한 과정이 동기 부여로 작용하여 더 멀리 달려나갈 수 있는 힘이 될 수 있도록 하였습니다.\r\n\r\n## 힘들다, 그래도 달려보자\r\n\r\n사실상 세 번째 실패와 관련된 이야기가 4주차 회고입니다. 4주차는 챌린지 마지막 주였기 때문에 더더욱 아쉬움이 많이 남는 한 주였습니다. 그리고 마지막 주차답게 또 한 번의 실패를 경험했습니다. 스스로 생각해본 이번 실패의 이유는 다음과 같습니다.\r\n\r\n### 체력, 집중력의 저하. 피로 누적\r\n\r\n주말에 분명 휴식을 취했다고 생각했음에도 불구하고, 4주가량 계속 진행해온 챌린지 활동으로 모르는 사이에 피로가 누적되고 있었습니다. 일 단위로 꾸준히 작성했던 회고록과 더불어 챌린지 활동 진행에 있어 꼼꼼함을 잃어버렸다고 생각합니다. 누적된 피로와 더불어 하루 루틴을 유지하지 못해 이로 인한 체력 저하와 더불어 집중력 저하도 크다고 생각합니다.\r\n\r\n### 개념의 부족\r\n\r\n이전에 실패를 경험했던 과제와 동일하게 상대적으로 이해가 부족한 개념이 바탕이 되는 과제였습니다. 이전에 개념을 이해하지 못해 개념에만 집중하여 정작 구현은 전혀 진행하지 못했던 경험이 있었기에 구현에만 너무 많은 시간을 소비하였습니다. 어느정도 이해하고 있는 개념과 관련된 과제에서는 이러한 자원 분배가 유연하게 잘 이루어졌는데 비해, 구현과 개념 중 한 방향으로 기울어지는 과제의 경우에는 이러한 기준이 아직 명확하지 않을 뿐더러 어떠한 시퀀스를 가지고 과제를 진행해야 하는지에 대한 고민이 많이 부족했습니다.\r\n\r\n<br/>\r\n\r\n집중력과 체력의 부족도 물론 영향이 있었지만, 무엇보다 **가지고 있는 기준을 유연하게 적용하지 못했던 것**이 가장 큰 이유라고 생각합니다.\r\n\r\n<br/>\r\n\r\n> **사실 기준은 크게 다른 점이 없습니다.**\r\n>\r\n> **→ 구현과 개념 정리, 어느 한 곳으로 기울지 않도록 예의 주시하는 것.**\r\n\r\n<br/>\r\n\r\n다만, 이러한 기준을 상황에 따라 어떻게 달리 적용하는지가 관건이 되겠습니다. 기준은 명확하되, 이를 얼마나 유동적으로 접근하고 적용할 수 있는지, 이에 대한 해결책을 고민해보는 것이 챌린지 이후의 스스로 던져주는 퀘스트라고 생각합니다.\r\n\r\n# 실패로 얻어낸 값진 성장\r\n\r\n![내준내상](prise.png)\r\n\r\n<br/>\r\n\r\n챌린지 과정은 매일이 새로운 도전이였습니다. 매번 생소한 개념을 바탕으로 진행하는 과제는 어렵게만 느껴지고, 이 과정에서 많은 고통을 느꼈습니다. 하지만 이제는 **이러한 과정을 즐길 수 있게 되었다**고 감히 말씀드릴 수 있을 것 같습니다. 사실 새로운 도전은 개념에 대한 도전보다는 **스스로의 한계에 대한 도전**이라고 할 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n또한 이러한 경험을 통해 **실패를 두려워하지 않는 나**로 성장할 수 있었습니다. 어떤 일을 시작할 때 항상 마음 한 켠에 가지고 있는 생각이 있었습니다.\r\n\r\n<br/>\r\n\r\n> **막상 시작했는데 너무 어려워서 포기하면 어떻게 하지? 이걸 내가 할 수 있을까?**\r\n\r\n<br/>\r\n\r\n아직 일어나지도 않은 실패에 대한 막연한 두려움이 크게 작용했다고 생각합니다. 이러한 생각을 항상 가지고 있었기에 무언가를 새롭게 도전하는 것이 항상 두려웠고, 쉽사리 도전해보지도 못했습니다.\r\n\r\n<br/>\r\n\r\n> **안전하게 넘어지는 방법을 배웠습니다.**\r\n\r\n실패를 두려워하지 않아야합니다. 사실 너무 당연한 이야기라 식상하긴 하지만, 두려워하지 않고 실패를 경험해보는 것이 정말 중요하다고 생각합니다. 계속 넘어지는 것을 반복하며 오히려 실패의 과정에서 성장하는 스스로를 발견하는 새로운 기회로 다가왔습니다. 또한 한 번 넘어져봤으니, 다음에는 더 안전하게 넘어지고 더 쉽게 일어날 수 있는 나만의 노하우가 생길 것이라 생각합니다.\r\n\r\n# 나만의 챌린지\r\n\r\n아직 챌린지는 끝나지 않았습니다. 챌린지에서 얻을 수 있었던 값진 경험을 바탕으로 지속적인 성장을 위한 나만의 작은 챌린지를 진행할까 합니다. 앞으로는 꾸준히 **주간, 월간, 연간 회고를 진행**할 예정입니다.\r\n\r\n<br/>\r\n\r\n회고는 인생에 있어 중요한 행동이라고 생각합니다. 내가 특정 기간동안 어떤 것을 목표로 두고 얼마나 노력했는지, 그 과정에서 어떤 것을 느꼈고 얼마나 개선할 수 있을지를 객관적으로 바라보며 과거를 되돌아볼 수 있습니다. 과거를 되돌아본 시간을 바탕으로 새로운 미래를 그려나갈 수도 있는 좋은 활동이라고 생각합니다.\r\n\r\n<br/>\r\n\r\n여기서 주간 회고가 나만의 애자일 스프린트라고 생각합니다. 짧은 기간에 대한 계획을 수립한 이후, 어떤 것을 느꼈는지 기록하며 **어제의 나보다 한 걸음 앞선 오늘의 나**를 만들기 위해 노력합니다.\r\n\r\n<br/>\r\n\r\n부족한 회고록을 읽어주셔서 감사드립니다.\r\n"},{"id":"aaad72aa-b018-5544-a78e-78ad6d60ddf1","frontmatter":{"title":"부스트캠프 웹・모바일 8기 챌린지 2주차 회고","icon":"TbFlame","date":"July 22, 2023"},"fields":{"slug":"/boostcamp/challenge-week2/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 챌린지 활동과 관련된 내용을 담고 있습니다.\r\n\r\n# 회고록 작성을 시작하며...\r\n\r\n또 다른 일주일이 지났습니다. 짧은 기간이지만 많은 생각과 고민을 이어나가게 되는 일주일이었습니다. 저번 주와 동일하게 회고록을 작성하며 한 주를 마무리합니다.\r\n\r\n# 그래도 2주차인데, 좀 익숙해지지 않았어?\r\n\r\n![그래도 하루에 12시간씩은 꼬박 투자하는데, 2주 정도 했으면 익숙해지지 않았을까?](cat.png)\r\n\r\n과연 익숙해졌을까요? 이번 일주일을 되돌아본다면 분명히 익숙해진 부분도 존재하겠지만, 아니라고 생각하는 부분이 더 컸습니다. 첫 일주일에 비해서는 과정 자체는 익숙해졌으나, 그 과정을 헤쳐 나가는 것은 쉽지만은 않았습니다.\r\n\r\n<br/>\r\n\r\n이번 주차에는 어떤 것을 달성했고, 느꼈고, 학습했는지와 아쉬운 부분에 대해 이야기를 풀어볼까 합니다.\r\n\r\n## 1주차의 규칙, 잘 지켜졌을까?\r\n\r\n1주차 회고를 진행하여 더 의미있고 효율적인 챌린지 활동이 되고자 몇 가지 규칙을 만들었습니다. 이를 2주차에 스스로 잘 적용했을까요? 1주차 회고록이 궁금하시다면 [여기](https://velog.io/@pexe99/2023-부스트캠프-Web-Mobile-8기-1주차-회고)를 참고해주세요.\r\n\r\n<br/>\r\n\r\n> **하루를 알차게 보내는 규칙**\r\n>\r\n> - ⭕ 개념 혹은 과제 어느 한 쪽에 너무 집중하지 말자.\r\n> - ⭕ 과제와 관련된 개념을 간단히 1~2시간 정도 공부하자.\r\n> - ⭕ 과제는 특정 시간이 되면 잠시 내려놓자.\r\n> - ❌ 과제도 중요하지만 개념도 중요하다. 개념 정리는 꼼꼼하게 하려고 노력해보자.\r\n> - ⭕ 특정 시간을 주기로 삼아 주기적으로 진행도를 체크해보자. 길을 찾을 수 있는 나침반이 될 것이다.\r\n> - ⭕ 정말 한 일이 없어도 새벽 2시에는 잠자리에 들자. 우리에게는 내일도 있다.\r\n> - ⭕ 잠시 다른 캠퍼들도 둘러보자. 내가 하는 고민들에 대한 답을 찾을 수도 있다.\r\n\r\n<br/>\r\n\r\n개념(학습)과 과제(구현) 사이의 균형을 잡는 것이 2주차의 주된 목표였습니다. 과제의 내용을 파악하고 개념으로 연관지을 수 있는 키워드를 정리하였습니다. 이후, 이를 바탕으로 키워드와 관련된 개념에 대해 학습하는 것에 초점을 두었습니다.\r\n\r\n<br/>\r\n\r\n짧은 시간 내에 지식을 **나만의 언어로 작성**하는 것은 쉽지 않다고 생각하였습니다. 대신, 이를 다른 사람이 읽고 이해할 수 있을 수준으로의 정리는 가능했습니다. 키워드를 중심으로 개념을 설명하며, **이 개념이 왜 중요한지, 다른 개념과는 어떻게 연관되는지**를 중심으로 정리하기 위한 연습 과정이었습니다.\r\n\r\n<br/>\r\n\r\n다만, 짧은 시간이었고 개념과 관련하여 깊은 부분까지 학습하기에는 학습 정리 과정이 미흡했습니다. 이와 관련하여 3주차에는 개선하고 구조화하는 것에 대한 노력이 필요할 것 같습니다.\r\n\r\n## 멘탈과 건강의 현 주소\r\n\r\n1주차에 비해서는 중심을 잡을 수 있었습니다. 특히나 주중에 진행되었던 커뮤니티 이벤트에서 나누었던 이야기들이 많은 도움이 되었습니다.\r\n\r\n<br/>\r\n\r\n> 다른 캠퍼들과 나를 비교하지 말자.\r\n\r\n<br/>\r\n\r\n1주차에 **하루를 아름답게 보내는 규칙**에 포함되었던 내용입니다. 나 스스로와 타인을 객관적으로 바라보는 것은 동기부여에 긍정적인 영향을 미치지만, 이에 매몰된다면 오히려 스스로를 갉아먹는 안좋은 습관이 될 수 있습니다. 실제로 1주차에서 이러한 비교를 무의식중에 반복하며 자신감과 자존감이 많이 떨어지기도 했습니다.\r\n\r\n<br/>\r\n\r\n타인과의 비교를 줄이고 스스로의 발전과 성장에 집중하는 것이 중요하지만, 동기부여를 위한 새로운 습관이 필요하다는 생각이 들었습니다. 이를 바탕으로 3주차에 새롭게 시작할 하나의 루틴은 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> **어제의 나와 오늘의 나를 비교하자**\r\n>\r\n> - 타인과의 과도한 비교는 스스로에게 독이 될 수 있다.\r\n> - 어제의 나와 오늘의 나에 대한 비교를 통해 스스로의 성장 과정을 객관화하자.\r\n> - 스스로에 대한 객관성을 길러 메타인지를 활성화하자.\r\n\r\n<br/>\r\n\r\n이를 위한 바탕은 바로 **일별 회고**가 되겠습니다. 2주차부터 의식적으로 회고록을 작성하고 있었지만, 단순히 오늘 어떤 내용을 학습했는지, 어떤 것들을 느꼈는지에 대한 내용이 위주였습니다. 물론 이러한 회고도 충분한 도움이 되었지만 회고 방식을 변경해볼까 합니다.\r\n\r\n## 새로운 회고 | 3L 회고법\r\n\r\n회고록을 작성하면서 하루에 내가 어떤 학습을 진행했는지, 아쉬운 점은 무엇이였는지에 대한 하루 단위 자가 피드백을 진행할 수 있었습니다. 이전까지는 커다란 일을 하나의 단위로 하여 크게 회고록을 작성했다면, 이번에는 가볍게 짧은 기간으로 끊어 회고하는 연습을 했다고 생각합니다.\r\n\r\n<br/>\r\n\r\n이러한 일 단위 회고가 이후에 주 단위, 더 나아가 월 단위와 연 단위의 회고에도 충분한 도움이 될 것 같습니다. 가령 ‘대회 나갔던 내용을 회고해야지’ 라는 생각으로 회고를 진행하려고 할 때, 분명 누구나 ‘근데 내가 뭘 했었지?’ 라는 생각을 시작으로 회고록 작성에 어려움을 겪었던 적이 있을 것이라 생각합니다. 저 또한 그러한 경험을 자주 했었고, 이번 일 단위 회고가 ‘꾸준한 기록’을 바탕으로 큰 단위의 회고를 진행하는데 있어 큰 도움이 될 것이라 생각합니다.\r\n\r\n<br/>\r\n\r\n다만, 스스로를 객관화하기에는 부족한 방식이라 생각합니다. 이를 위해 3주차에는 `3L 회고법`을 도입하여 루틴화를 해볼 예정입니다. 3L 회고법은 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n> **3L 회고법**\r\n>\r\n> - 3L은 각각 아래를 의미합니다.\r\n>\r\n>   - `Liked` : 만족스러웠던 점\r\n>   - `Learned` : 배웠던 점\r\n>   - `Lacked` : 부족하거나 아쉬웠던 점\r\n>\r\n> - 위와 같이 크게 3가지 영역으로 나누어 회고를 진행합니다. 3L 회고법에 대한 내용은 [여기](https://velog.io/@alstnsrl98/%EC%95%A0%EC%9E%90%EC%9D%BC%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%9A%8C%EA%B3%A0)를 참고하였습니다.\r\n\r\n# 회고록을 마치며...\r\n\r\n회고 이외에도 3주차에는 성장을 위해 추가적인 노력들이 필요하다고 생각합니다. 나만의 학습 정리 방식을 찾아 이를 구조화하여 보다 빠르게 개념들을 정리하고 체화하는 연습은 물론, 건강을 위한 소소한 루틴을 자리잡기 위한 연습도 필요할 것입니다.\r\n\r\n<br/>\r\n\r\n부족한 글을 읽어주셔서 감사드립니다. 3주차에는 2주차보다 아쉬움의 무게가 가벼워질 수 있도록 노력해보겠습니다.\r\n"},{"id":"f04ef679-3ad6-546c-8421-a2519b2a9a3f","frontmatter":{"title":"[Boarlog] 끝을 향한 우리들의 시작.","icon":"TbMoodSmile","date":"November 24, 2023"},"fields":{"slug":"/boarlog/team/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n## 그룹 프로젝트의 시작\r\n\r\n부스트캠프 웹・모바일 8기에 지원하고, 챌린지 과정을 거쳐 멤버십까지 정말 순식간에 지나간 2023년 하반기입니다. 두 번의 학습 스프린트를 끝마치고 그룹 프로젝트만 남아있는 지금, 이 순간을 기록으로 남깁니다.\r\n\r\n<br/>\r\n\r\n이번 포스팅은 저희 팀에 대한 소개와 더불어 그룹 프로젝트의 주제 선정 과정에 대해 다루고자 합니다. 프로젝트를 진행함에 있어 가장 큰 일들 중 하나인 ‘주제 선정’과 관련하여 어떠한 고민들을 중심으로 이야기를 나누었고, 그 과정에서 어떠한 결론을 도출해냈는지에 대해 공유드리고자 합니다.\r\n\r\n## 팀 소개\r\n\r\n### 우리는 무엇에 집중하고자 하는가?\r\n\r\n![우리의 시작은 slack으로부터](slack.png)\r\n\r\n어떤 집단이라도, 집단 크기가 다르고 성격도 다르더라도 공통적으로 모든 집단 구성원들이 가지고 있는 “목표”가 존재합니다. 그 목표가 얼마나 명확한지, 어떠한 목표를 가지고 있는지에 따라 집단의 방향성이 결정되는 만큼 **우리는 어떠한 목표를 가지고 있는가**에 대해 생각해보는 것이 중요하다고 생각합니다.\r\n\r\n<br/>\r\n\r\n저는 이전까지 몇 가지 토이 프로젝트 혹은 해커톤을 경험하며 “그래서 이러한 프로젝트를 통해 어떤 것을 얻었는가?”라고 누가 질문을 던진다면 명확히 답변할 자신이 없었습니다.\r\n\r\n<br/>\r\n\r\n해커톤에 참여하기 위한 프로젝트의 경우, 단기간 안에 빠르게 구현해내는 것이 1순위였기에 우리가 활용한 기술 혹은 라이브러리가 정확히 어떤 역할을 하고, 어떠한 방식으로 작동하는지에 대해 생각해보지 못했습니다. 열심히 시간을 투자해 구현을 마친다고 하더라도 실질적으로 해커톤 데모데이 당일에만 사용되고 버려질 프로젝트가 대부분이었기에 실질적으로 사용할 수 있는 프로젝트를 진행해보고 싶다는 열망이 생겼습니다.\r\n\r\n![멋쟁이사자처럼 인하대학교 11기 공지/과제 제출 플랫폼 Lionz](lionz.png)\r\n\r\n![인하대학교 2023 비룡제 홈페이지](festival.png)\r\n\r\n그래서 동아리 내부에서 활용할 수 있는 **공지/과제 제출 플랫폼 Lionz**와 다양한 사람들이 사용해볼 수 있는 **인하대학교 2023 비룡제 홈페이지**를 구상하여 프로젝트를 진행하였습니다. 해당 프로젝트들을 통해서 다음과 같은 경험을 할 수 있었습니다.\r\n\r\n<br/>\r\n\r\n> **위 프로젝트들을 통해 경험한 것들**\r\n>\r\n> - 프로젝트 기획 과정의 중요함을 깨달았습니다. 모호하게 정의된 각각의 기능들은 이후 발생하는 변경사항들을 적용하고 고민하는 과정에 많은 시간을 투자하도록 하였습니다.\r\n> - 프로젝트를 마치고 그만두는 것이 아니라 일부 개선 과정을 경험하였습니다. 모바일 환경에서의 접근성 고려와 더불어 일부 기능들의 경우, 정상 작동하지 않거나 오류가 발생했을 경우에 추가적인 처리와 개선 작업을 진행하였습니다.\r\n\r\n<br/>\r\n\r\n다만, **내가 이 기술을 왜 선택했고, 어떠한 고민들을 했는가?** 에 대해서는 여전히 생각해보지 못했습니다.\r\n\r\n### 우리만의 규칙 정하기\r\n\r\n저희 팀은 **기술적인 deep dive를 경험하자**가 모든 구성원이 긍정하는 공통된 목표였습니다. 이전까지 기술적인 고민들을 많이 시도해보지 못했고, 이러한 경험을 꼭 가져가고 싶다는 의견이 일치했기에 주된 목표로 선정하였습니다. 이전과는 다른 방식으로 프로젝트를 진행하게 되어 설레이는 감정도 있었지만 한 켠에는 시도해보지 않았던 목표이기에 무리없이 진행할 수 있을지에 대한 막연한 두려움도 있었습니다.\r\n\r\n<br/>\r\n\r\n기술적인 고민과 더불어 깊은 학습을 위해서는 ‘우리가 왜 이 기술을 택했는지’에 대한 논의 과정이 반드시 필요합니다. 이 과정에서 특정 기능을 구현하기 위해 다양한 기술 혹은 라이브러리를 찾아보게 되고, 어떤 것을 사용할지에 대해 의견을 나누는 과정에서의 충돌도 생길 수 있습니다.\r\n\r\n<br/>\r\n\r\n그렇기에 팀 안에서 서로를 존중하며 소통하기 위한 팀 규칙을 정했습니다. 특히나 소통이 가장 중요하다고 생각했기 때문에 ‘솔직함’을 가장 중요한 가치로 생각하였습니다. 내 상태를 객관적으로 파악하고 팀원들에게 공유하는 것, 내가 어떤 것을 모르고 어떤 것을 아는지 확실히 하고 팀원들과 의문점에 대해 논의하는 것에 있어서 필수적인 요소라 생각했기 때문입니다.\r\n\r\n<br/>\r\n\r\n> **우리들의 규칙**\r\n>\r\n> - 지구 종말 상황에도 빠르게 연락을 나눌 수 있는 핫라인을 만들고 잘 유지하자.\r\n> - 30분 이상 해결되지 않는 고민은 팀원들과 논의하자.\r\n> - 꼭 **건강하자**. (자신의 상태에 대해 솔직하게 공유하자. ~~거짓말은 죽음 뿐이다~~)\r\n> - 다른 조의 진행 상황을 보면서 초조해하지 않기로 하자. (~~우리가 최고다!~~)\r\n> - 오프라인으로 만나면 **사진**으로 남기자.\r\n\r\n### TEAM_528\r\n\r\n![빼빼로 산타와 우리 팀](photo.png)\r\n\r\n이러한 팀 문화를 바탕으로 TEAM_528이 결성되었습니다. **`528`**은 팀원 5명의 캠퍼 번호를 더한 숫자로, 5명의 캠퍼가 서로 다른 기술, 경험, 및 아이디어를 결합하여 시너지를 발휘하고자 하는 뜻을 담고 있습니다.\r\n\r\n## 주제 선정 과정\r\n\r\n우리가 이번 프로젝트를 통해 가져가고자 하는 것은 무엇인지를 중심으로 주제를 고민하였습니다. 주제 선정 과정에서 항상 고민하게 되는 부분들이 있습니다.\r\n\r\n<br/>\r\n\r\n> **고민거리들**\r\n>\r\n> - 이미 있는 서비스인데… 의미가 없지 않을까?\r\n> - 조금 더 색다른 아이디어는 없을까?\r\n> - 이걸 개발할 수 있을까?\r\n\r\n<br/>\r\n\r\n특히나 이미 존재하거나 유사한 서비스들이 있기에 새롭게 프로젝트를 시작하는 시점에는 색다른 아이디어 혹은 추가 기능 등을 생각하기 마련입니다. 다만, 저희 팀의 목표는 **기술적인 성장**이기에 다른 방식으로 생각하기로 했습니다.\r\n\r\n<br/>\r\n\r\n> **새로운 고민들**\r\n>\r\n> - 이 서비스에는 어떤 기능들이 메인일까?\r\n> - 이 기능들을 구현한다면 **어떤 기술들이 필요할까?**\r\n> - 이 프로젝트를 통해 **우리는 무엇을 얻어갈 수 있을까?**\r\n\r\n유사한 서비스가 있다고 하더라도 이를 직접 기획하고 설계하는 과정을 거쳐 직접 구현해보는 것에 의의가 있다고 생각했습니다. 유저들이 자유롭게 이용할 수 있는 커뮤니티형 서비스의 경우, 기술적으로 크게 도전할 수 있는 메인 기능을 정하기 어려울 것으로 판단하여 제외하기로 결정하였습니다.\r\n\r\n### 우리가 결정한 주제\r\n\r\n![고민의 흔적들 (feat. Figjam)](figjam.png)\r\n\r\n기술적인 면에서의 도전할 수 있는 기능들을 중심으로 구상하여 각각의 장단점을 생각해본 결과, 저희는 Figjam과 유사한 형태의 서비스를 구현해보고자 결정하였습니다. 부스트캠프 커뮤니티 내에서도 사용할 수 있도록 여기에 추가적인 기능들을 구상하여 **실시간 화이트보드 강의 서비스**를 주제로 결정하였습니다.\r\n\r\n<br/>\r\n\r\n프론트엔드, 백엔드 파트 전부 기술적으로 도전할 수 있는 주제이기도 하며, 추후에 확장 가능한 기능들을 쉽게 구상할 수 있다는 점이 큰 장점이었습니다. 개발자 커뮤니티에서도 지식 공유를 위해 간단하게 사용할 수 있어 프로젝트를 완성하고 이를 실제로 직접 사용해볼 수 있다는 점도 주제로 선정하게 된 이유이기도 합니다.\r\n\r\n<br/>\r\n\r\n> **우리 서비스의 핵심 기능들**\r\n>\r\n> - 화이트보드를 자유롭게 편집할 수 있어야 한다.\r\n> - 음성 채팅과 실시간 채팅도 고려해보자.\r\n> - 이를 로그 형태로 남겨 다시 볼 수 있도록 하자.\r\n\r\n<br/>\r\n\r\n저희 팀의 도전은 지금부터 시작입니다. 이번 프로젝트가 모두에게 있어 도약을 위한 도전이 될 수 있도록 노력해보고자 합니다.\r\n\r\n<br/>\r\n\r\n> **항상 적극적으로 프로젝트에 참여해주신 우리 팀원분들께 감사의 말을 전합니다.**\r\n"},{"id":"e9fda44d-22ad-5f9a-91d3-7c49fd32d599","frontmatter":{"title":"마법같은 정규 표현식","icon":"TbBrandJavascript","date":"August 07, 2023"},"fields":{"slug":"/javascript/named-capturing-group/"},"rawMarkdownBody":"\r\n# 블로깅 시작 전에\r\n\r\n프로그래머스 문제를 많이 접하면서 `정규 표현식`의 존재를 알게 되었습니다. 이전에 프로젝트 진행 과정에서 이메일 혹은 비밀번호나 아이디 등을 사용자가 입력했을 때, 해당 입력값이 적합한지 판단하게 위해서 `정규 표현식`을 사용하기도 했었습니다.\r\n\r\n<br/>\r\n\r\n하지만 매번 `정규 표현식`을 사용할 때, 단순히 구글링을 통해서 긁어와 사용해왔습니다. 이렇게 미루어왔던 `정규 표현식`에 대해 알아보고 넘어가고자 포스팅을 진행하게 되었습니다.\r\n\r\n<br/>\r\n\r\n그리고 이번 포스팅의 주제처럼 **정말 마법같은 정규 표현식의 기능 중 하나**인 `Named Capturing Group`에 대해서도 함께 알아보겠습니다.\r\n\r\n# Regular Expression?\r\n\r\n![](regexp.png)\r\n\r\n<br/>\r\n\r\n`Regular Expression`, 다른 말로 `정규 표현식`은 **특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어**입니다. 여기서 형식 언어는 다음과 같은 의미를 가지고 있습니다.\r\n\r\n<br/>\r\n\r\n> [**형식 언어 - formal language**](https://ko.wikipedia.org/wiki/%ED%98%95%EC%8B%9D_%EC%96%B8%EC%96%B4)\r\n>\r\n> - 특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합을 말한다.\r\n\r\n<br/>\r\n\r\n쉽게 말하자면 **문자열의 특정 형식**을 **표현할 수 있는 방법**이라고 할 수도 있겠습니다. 초반에는 텍스트 편집기에서의 패턴 매칭으로 사용되었기도 하였으며, 수학적인 의미로 시작되었다고 합니다. 지금은 프로그래밍 언어에서 문자열 검색과 치환을 위해서도 사용되고 있습니다.\r\n\r\n<br/>\r\n\r\n정규 표현식을 사용하면 문자열에 대한 특정 조건을 매우 간단하게 표현할 수 있지만, 특정 표현이 있기 때문에 정규 표현식을 모른다면 이를 이해할 수 없습니다. 이러한 정규 표현식은 `meta 문자`로 구성되어 있습니다.\r\n\r\n## meta 문자\r\n\r\n> **meta 문자**\r\n>\r\n> - 표현식 내부에서 특정한 의미를 갖는 문자(기호)\r\n\r\n<br/>\r\n\r\n좀 더 정리하자면, 단순 문자가 아닌 다른 용도로 사용되는 문자를 말합니다. 단일 문자 또는 `\\` 가 붙은 단일 문자의 형태로 사용됩니다. 메타 문자는 검사 범위를 지정하거나 수량 혹은 검사 위치를 나타내기도 합니다. 이에 대한 내용을 정리하자면 아래와 같습니다.\r\n\r\n### 정규 표현식 정리\r\n\r\n|   표현식   | 의미                                                                                              |\r\n| :--------: | ------------------------------------------------------------------------------------------------- |\r\n|    `^x`    | 문자열의 시작을 표현. x 문자로 시작됨을 의미                                                      |\r\n|    `x$`    | 문자열의 종료를 표현. x 문자로 종료됨을 의미                                                      |\r\n|    `.x`    | 임의의 한 문자의 자리수를 표현하며 문자열이 x 로 끝난다는 것을 의미                               |\r\n|    `x+`    | 반복을 표현하며 x 문자가 한 번 이상 반복됨을 의미 (1개 이상)                                      |\r\n|    `x?`    | 존재 여부를 표현하며 x 문자가 존재할 수도 아닐 수도 있음                                          |\r\n|    `x*`    | 반복 여부를 표현하며 x 문자가 0번 또는 그 이상 반복됨을 의미 (0개 이상)                           |\r\n|  `x`\\|`y`  | or 를 표현하며 x 또는 y 문자가 존재함을 의미                                                      |\r\n|   `(x)`    | 그룹을 표현하며 x 를 그룹으로 처리함을 의미                                                       |\r\n|  `(x)(y)`  | 그룹들의 집합을 표현하며, 앞부터 순서대로 번호를 부여하여 관리. x, y는 각 그룹의 데이터로 관리됨. |\r\n| `(x)(?:y)` | 그룹들의 집합에 대한 예외를 표현하며 그룹 집합으로 관리되지 않음을 의미                           |\r\n|   `x{n}`   | 반복을 표현하며 x 문자가 n번 반복됨을 의미                                                        |\r\n|  `x{n,}`   | 반복을 표현하며 x 문자가 n번 이상 반복됨을 의미                                                   |\r\n|  `x{n,m}`  | 반복을 표현하며 x 문자가 최소 n번 이상 최대 m 번 이하로 반복됨을 의미                             |\r\n|   `[xy]`   | 문자 선택을 표현하며 x 와 y 중 하나를 의미                                                        |\r\n|   `^xy`    | not 을 표현하며 x 및 y 를 제외한 문자를 의미                                                      |\r\n|  `[x-z]`   | range 를 표현하며 x ~ z 사이의 문자를 의미                                                        |\r\n|    `\\^`    | escape 를 표현하며 ^ 를 문자로 사용함을 의미                                                      |\r\n|    `\\b`    | word boundary 를 표현하며 문자와 공백 사이의 문자를 의미                                          |\r\n|    `\\B`    | non word boundary 를 표현하며 문자와 공백 사이가 아닌 문자를 의미                                 |\r\n|    `\\d`    | digit 를 표현하며 숫자를 의미                                                                     |\r\n|    `\\D`    | non digit 를 표현하며 숫자가 아닌 것을 의미                                                       |\r\n|    `\\s`    | space 를 표현하며 공백 문자를 의미                                                                |\r\n|    `\\S`    | non Space 를 표현하며 공백 문자가 아님을 의미                                                     |\r\n|    `\\t`    | tab 을 표현하며 탭 문자를 의미                                                                    |\r\n|    `\\v`    | vertical tab 을 표현하며 수직 탭 문자를 의미                                                      |\r\n|    `\\w`    | word 를 표현하며 알파벳, 숫자, \\_ 중의 한 문자임을 의미                                           |\r\n|    `\\W`    | non word 를 표현하며 word 가 아닌 문자를 의미                                                     |\r\n\r\n> 해당 내용은 [이 블로그](https://hamait.tistory.com/342)를 참고하여 작성하였습니다.\r\n\r\n### Flag\r\n\r\n정규 표현식을 사용함에 있어 `Flag`를 사용할 수 있습니다. `Flag`는 특정 의미를 가지고 있으며, `Flag`를 사용하지 않는 경우에는 문자열에 대한 검색을 한 번만 처리하고 종료하게 됩니다.\r\n\r\n| Flag | 의미                                                            |\r\n| :--: | --------------------------------------------------------------- |\r\n| `g`  | `Global` : 대상 문자열 내의 모든 패턴을 검색                    |\r\n| `i`  | `ignore case` : 대상 문자열에서 대/소문자 식별하지 않음         |\r\n| `m`  | `Multi line` : 대상 문자열이 다중 라인의 문자열인 경우에도 검색 |\r\n\r\n# RegExp 사용법\r\n\r\n그렇다면, 이러한 정규 표현식을 `JavaScript`에서 어떻게 활용할까요? 관련된 method들을 살펴보겠습니다.\r\n\r\n## exec()\r\n\r\n`exec`은 **문자열에 대해 특정 부분이 일치하는지를 탐색하여 이에 대한 결과를 알려줍니다**. 결과가 존재하는 경우에는 이에 대한 정보를, 아닌 경우에는 `null`을 반환하여 이를 바탕으로 특정 문자가 존재하는지 판단할 수 있습니다.\r\n\r\n<br/>\r\n\r\n단순히 일치 여부를 탐색하는 기능에서 더 나아가 `global` flag를 설정하면 `exec`을 활용하여 일치하는 각 부분의 index를 탐색할 수 있습니다. `g flag`를 설정한 regexp로 `exec`를 실행하면, `regexp`에서 `lastIndex`가 변화합니다. 여기서 `lastIndex`는 바로 이전에 일치한 부분의 index에 대한 정보를 가지고 있습니다.\r\n\r\n<br/>\r\n\r\n예시를 살펴보며 이해해봅시다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 문자열에 대해 global flag를 설정한 정규 표현식\r\nconst catRegExp = /cat/g\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log(catRegExp.exec(test1), catRegExp.lastIndex)\r\nconsole.log(catRegExp.exec(test1), catRegExp.lastIndex)\r\n\r\n/*\r\n[\r\n  'cat',\r\n  index: 7,\r\n  input: 'i love cat. cat dominates the world.',\r\n  groups: undefined\r\n] 10\r\n[\r\n  'cat',\r\n  index: 12,\r\n  input: 'i love cat. cat dominates the world.',\r\n  groups: undefined\r\n] 15\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n위와 같이 일치하는 문자열의 위치를 `exec`을 이용하여 쉽게 찾을 수 있습니다.\r\n\r\n## test()\r\n\r\n위에서 언급한 `exec`을 활용해서 정규 표현식을 만족하는지에 대해 판단할 수도 있지만, `test`를 이용하는 것이 목적에 부합하며, 공식 문서에서도 이를 권장하고 있습니다. 주어진 문자열이 해당 정규 표현식을 만족하는지에 대한 여부를 `true/false`로 return 합니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 정규 표현식\r\nconst catRegExp = /cat/\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log(catRegExp.test(test1))\r\n\r\n/*\r\ntrue\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n중요한 것은 위의 예시는 **해당 정규 표현식에 대한 문자열이 포함되어 있다면 `true`**라는 것입니다. 특정 문자열 형식과 완전히 동일한지에 대한 여부를 판단하기 위해서는 시작과 끝에 대한 정규 표현식을 작성하도록 합시다.\r\n\r\n## match()\r\n\r\n`match`는 **주어진 문자열이 정규 표현식과 일치하는 부분을 return** 합니다. 어라? `exec`와의 차이점이 없는 것 같지 않나요? 맞습니다. `g flag`를 설정하지 않는다면 `match`는 `exec`와 동일하게 작동합니다. 그렇다면 `g flag`를 설정한다면 어떻게 작동할까요? 바로 **매칭되는 부분을 배열로 return** 하게 됩니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// A부터 E까지의 정규 표현식\r\nconst alpha = /[A-E]/g\r\n\r\n// test 문자열\r\nconst test1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n\r\n// 결과 출력\r\nconsole.log(test1.match(alpha))\r\n\r\n/*\r\n[ 'A', 'B', 'C', 'D', 'E' ]\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n이와 비슷하면서도 다른 `matchAll`도 존재합니다. `matchAll`은 단순히 매칭된 값에 대한 배열만을 return 하는 것이 아닌, **capture group에 대한 정보도 같이 담아 return** 합니다.\r\n\r\n<br/>\r\n\r\n> **Capture group**\r\n>\r\n> - 정규 표현식에서 `()`로 감싼 그룹\r\n\r\n<br/>\r\n\r\n어떻게 동작하는지는 예시를 통해 살펴보겠습니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 정규 표현식\r\nconst catRegExp = /(c(a(t)))/g\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log([...test1.matchAll(catRegExp)])\r\n\r\n/*\r\n[\r\n  [\r\n    'cat',\r\n    'cat',\r\n    'at',\r\n    't',\r\n    index: 7,\r\n    input: 'i love cat. cat dominates the world.',\r\n    groups: undefined\r\n  ],\r\n  [\r\n    'cat',\r\n    'cat',\r\n    'at',\r\n    't',\r\n    index: 12,\r\n    input: 'i love cat. cat dominates the world.',\r\n    groups: undefined\r\n  ]\r\n]\r\n*/\r\n```\r\n\r\n## Named Capturing Group\r\n\r\n**이번 정규 표현식 포스팅의 핵심**입니다. 정규 표현식 기능 중 하나로, 정규 표현식 패턴에 매칭된 그룹에 특정한 이름을 주는 것입니다. 이 기능은 아래와 같은 문법으로 사용이 가능합니다.\r\n\r\n<br/>\r\n\r\n```\r\n(?<name>pattern)\r\n```\r\n\r\n<br/>\r\n\r\n해당 기능을 사용하면 `match`로 return 받는 array 내부의 `group` 속성에 `name : value` 쌍의 프로퍼티로 이루어진 객체로 매칭된 데이터를 받아올 수 있게 됩니다. **정규 표현식으로 단순히 문자열 내의 특정 값을 캐치하는 것에서 끝나는 것이 아닌, 파싱까지 가능하다?**... 정말 마법같은 기능입니다!🪄 이를 바탕으로 예시를 작성하자면 아래와 같습니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// 이름, 성, 전화번호가 공백으로 구분된 문자열을\r\n// 파싱하기 위한 정규 표현식\r\nconst personalInfo =\r\n  /(?<firstName>[\\w]+)\\s+(?<lastName>[\\w]+)\\s+(?<number>[\\d]+)/\r\n\r\n// test 문자열\r\nconst test1 = \"Harry Potter 01012345678\"\r\n\r\n// match 결과 출력\r\nconsole.log(test1.match(personalInfo))\r\n\r\n/*\r\n[\r\n  'Harry Potter 01012345678',\r\n  'Harry',\r\n  'Potter',\r\n  '01012345678',\r\n  index: 0,\r\n  input: 'Harry Potter 01012345678',\r\n  groups: [Object: null prototype] {\r\n    firstName: 'Harry',\r\n    lastName: 'Potter',\r\n    number: '01012345678'\r\n  }\r\n]\r\n*/\r\n\r\n// 전화번호 출력\r\nconsole.log(test1.match(personalInfo).groups.number)\r\n\r\n/*\r\n01012345678\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n정말 너무나도 간편하게 **문자열에서 원하는 부분만 파싱하여 바로 객체 형태로 return** 받을 수 있습니다. 특정 seperator를 기준으로 직접 `split`을 진행하여 저장했던 이전 방식과 비교할 수 없을 만큼 간단합니다.\r\n\r\n## search()\r\n\r\n`search`는 **주어진 문자열에서 정규 표현식과 일치하는 가장 첫 번째 부분의 index를 return** 합니다. 찾지 못할 경우에는 `-1`을 return 합니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 정규표현식\r\nconst catRegExp = /cat/\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log(test1.search(catRegExp))\r\n\r\n/*\r\n7\r\n*/\r\n```\r\n\r\n## replace()\r\n\r\n`replace`에서도 정규 표현식을 사용할 수 있다는 사실, 알고 계셨나요? `replace`는 **정규 표현식에 해당하는 문자열을 변경**해줍니다. 예시를 살펴봅시다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 정규표현식\r\nconst catRegExp = /cat/\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log(test1.replace(catRegExp, \"dog\"))\r\n\r\n/*\r\ni love dog. cat dominates the world.\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n이와 비슷한 `replaceAll`이라는 method도 존재합니다. `replaceAll`은 정규 표현식에 해당하는 모든 부분을 해당 문자열로 교체해줍니다. 단, `g flag`를 꼭 설정해야 합니다.\r\n\r\n<br/>\r\n\r\n```js\r\n// cat 정규표현식\r\nconst catRegExp = /cat/g\r\n\r\n// test 문자열\r\nconst test1 = \"i love cat. cat dominates the world.\"\r\n\r\n// 결과 출력\r\nconsole.log(test1.replaceAll(catRegExp, \"dog\"))\r\n\r\n/*\r\ni love dog. dog dominates the world.\r\n*/\r\n```\r\n\r\n<br/>\r\n\r\n사실 **`replace`에서 인자로 넘겨주는 정규 표현식에 `g flag`를 설정해주는 것으로 `replaceAll`과 동일한 동작**을 하도록 할 수 있습니다. 차이점이라면 `replaceAll`은 `g flag`가 설정되지 않는다면 오류가 발생한다는 점입니다. 명시적으로 **모두 변경함**을 나타내고 싶다면 `replaceAll`을 사용하면 되겠습니다.\r\n\r\n# 참고\r\n\r\n- [MDN web docs 정규 표현식 번역본](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Regular_expressions)\r\n- [RegExp.prototype.exec()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\r\n- [RegExp.prototype.test()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\r\n- [String.prototype.match()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match)\r\n- [String.prototype.matchAll()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)\r\n- [Named capturing group: (?<name\\>...)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Named_capturing_group)\r\n- [String.prototype.search()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/search)\r\n- [String.prototype.replace()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replace)\r\n- [String.prototype.replaceAll()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n"},{"id":"b92a4b85-6c28-5e64-bc3e-597624432a40","frontmatter":{"title":"[Boarlog] 라이브러리 없이 Toast 만들기(feat. TailwindCSS, recoil)","icon":"TbBread","date":"November 26, 2023"},"fields":{"slug":"/boarlog/toast/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n<br/>\r\n\r\n> **구현 결과 미리보기**\r\n>\r\n> ![](result.gif)\r\n\r\n## 포스팅에 앞서\r\n\r\n일반적인 서비스에서 항상 필요로 하는 요소들 중 하나인 Toast를 어떻게 현재 프로젝트에서 사용할지에 대해 고민이었습니다. 이전까지 참여했던 프로젝트에서는 대부분 Toast 라이브러리를 활용했기에 이번에는 직접 Toast를 구현하기로 결정하였습니다.\r\n\r\n<br/>\r\n\r\n이번 포스팅은 Toast를 어떻게 구현하였는지, 구현한 Toast가 어떤 과정을 통해 동작하는지와 관련된 내용을 담고 있습니다. Toast를 직접 구현하고자 하는 분들에게 도움이 될 수 있기를 바랍니다.\r\n\r\n### Toast가 뭔데?\r\n\r\nToast는 쉽게 말해 휴대전화의 알림창과 유사한 요소입니. 특정 동작에 대한 간단한 내용을 팝업하여 잠시 보여주고 사라지는 형태에 해당됩니다. 토스트기에서 빵이 튀어오르는 모습과 동일해 Toast라는 이름을 가지고 있습니다. 이러한 Toast는 서비스를 사용하는 과정에서 아주 쉽게 만나볼 수 있습니다.\r\n\r\n![토스 앱 - 운세 확인 페이지 토스트 예시](toss.png)\r\n\r\n아이디를 입력하지 않았거나, 로그인이 정상적으로 진행되는 등 특정 작업들에 대한 성공 여부를 사용자에게 가볍게 전달하기에 효과적이기 때문에 자주 사용됩니다.\r\n\r\n## Toast 구현 이전의 고민들\r\n\r\n위와 같은 Toast를 프로젝트에서 활용할 때는 이전까지 `react-simple-toasts` 등의 라이브러리를 사용하였습니다. 직접 구현하기에 앞서 `react-simple-toasts`는 어떻게 동작하는지를 다시 확인해보았습니다.\r\n\r\n<br/>\r\n\r\n> **[react-simple-toasts github repository](https://github.com/almond-bongbong/react-simple-toasts)**\r\n\r\n<br/>\r\n\r\n![](lionz.gif)\r\n\r\n<br/>\r\n\r\n> **[react-simple-toasts 활용 예제 프로젝트](https://github.com/lionz-11/lionz-inha)**\r\n\r\n<br/>\r\n\r\n![](lionzHTML.png)\r\n\r\n<br/>\r\n\r\n우선 `root` 내부에서 Toast를 관리하는 것이 아닌, 바깥에서 관리하는 것을 확인할 수 있습니다. 또한 Toast의 위치별로 container를 두어 Toast 생성 시에 해당 `div` 태그 내부에서 생성하도록 함을 확인할 수 있었습니다. 또한 특정 시간이 지나면 생성한 요소를 다시 삭제하여 각 container는 비어있는 상태를 유지하도록 동작하고 있습니다.\r\n\r\n<br/>\r\n\r\n이러한 동작 과정을 바탕으로 아래와 같은 고민에 대한 답을 얻을 수 있었습니다.\r\n\r\n### 고민 1: 전역으로 관리해야 하는가?\r\n\r\nToast는 페이지 곳곳에서 사용됩니다. 버튼을 클릭하거나, 특정 페이지로 이동했을 경우 등 다양한 event와 연결지어 사용자에게 정보를 전달해주는 역할을 담당하고 있습니다. Toast의 내용을 지역적으로 관리할 경우, component의 형태로 각 페이지마다 가져와 사용해야 합니다.\r\n\r\n<br/>\r\n\r\n다만, 페이지에서 페이지로 이동하는 과정에서 Toast를 사용하게 된다면 어떻게 될까요? 페이지 전체가 새로 그려지기 때문에 당연히 이동하기 전 페이지에서 ‘환영합니다’와 같은 메세지를 Toast로 전달한다고 하더라도 이후 페이지로 이동하면서 Toast가 사라지게 될 것입니다.\r\n\r\n<br/>\r\n\r\n또한 각 페이지마다 state를 각각 만들어 관리해야 하기 때문에 복잡해지는 것은 물론, 페이지의 하위 component에서 Toast를 사용하기 위해 state를 prop로 전달해주는 과정에서의 prop dilling도 문제가 될 수 있습니다.\r\n\r\n<br/>\r\n\r\n![](propsDrilling.png)\r\n\r\n<br/>\r\n\r\n> **prop drilling이란?**\r\n>\r\n> prop를 하위 component로 전달하는 용도로만 사용되는 component를 거치면서 데이터를 전달하는 과정에 해당합니다. 단순히 1개에서 2개 정도를 거치는 수준이면 문제가 되지 않지만, component의 부모 자식 관계의 깊이가 깊어질 수록 거치는 component의 수도 많아지기 때문에 추적이 어려워집니다.\r\n\r\n<br/>\r\n\r\n이러한 Toast state를 전역에서 관리해준다면 문제를 해결할 수 있습니다. 공통된 state를 공유하기 때문에 각 페이지에서 state를 따로 가지고 있을 필요도 없으며, 하위로 전달해줄 state가 없기 때문에 Toast state와 관련된 prop drilling을 신경쓰지 않을 수 있습니다.\r\n\r\n### 고민 2: 부모 트리 밖에서 그려야 하는가?\r\n\r\n일반적으로 React에서 element는 `root` 하위의 DOM 계층 구조의 자식으로 렌더링됩니다. 다만, Toast는 ‘알림’의 기능을 담당하기 때문에 모든 요소의 최상단에 표시되어야 합니다. 물론 `z-index`와 `position: fixed` 등을 이용하여 이를 표시할 수 있지만, 불필요한 요소가 추가적으로 필요할 수 있음은 물론, 의도한 방식으로 작동하지 않을 가능성도 있습니다.\r\n\r\n<br/>\r\n\r\n이를 부모 트리 밖으로 구분하여 관리한다면 이러한 문제 혹은 이슈를 해결할 수 있습니다.\r\n\r\n<br/>\r\n\r\n> **[React Portals 공식 문서](https://ko.legacy.reactjs.org/docs/portals.html)**\r\n\r\n<br/>\r\n\r\nReact에서는 `createPortal`이라는 방법을 제공하고 있습니다. 이를 활용하면 DOM 계층 구조 바깥의 DOM 노드 하위에 특정 요소들을 렌더링할 수 있도록 할 수 있습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nrender() {\r\n  // React는 새로운 div를 생성하지 *않고* `domNode` 안에 자식을 렌더링합니다.\r\n  // `domNode`는 DOM 노드라면 어떠한 것이든 유효하고, 그것은 DOM 내부의 어디에 있든지 상관없습니다.\r\n  return ReactDOM.createPortal(\r\n    this.props.children,\r\n    domNode\r\n  );\r\n}\r\n```\r\n\r\n## Toast 구현하기\r\n\r\n이러한 조건들을 바탕으로 Toast를 구현해보겠습니다. 현재 그룹 프로젝트에서는 `TailwindCSS`와 `recoil`을 활용하고 있으므로, 스타일링에는 `Tailwind`를, 전역 상태 관리에는 `recoil`을 사용하였습니다.\r\n\r\n### recoil로 Toast 전역 상태 관리하기\r\n\r\n우선 `recoil`을 이용하여 전역 상태를 관리하기 위해 `atom`을 작성하였습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n// toastAtom.ts\r\nimport { atom } from \"recoil\";\r\nimport { ToastMessage } from \"./toastType\";\r\n\r\nexport const toastListState = atom<ToastMessage[]>({\r\n  key: \"toastListState\",\r\n  default: []\r\n});\r\n```\r\n\r\n<br/>\r\n\r\n위에서 살펴보았던 Toast 예제에서는 한 개의 Toast만 존재하지만, 특정 이벤트가 여러번 발생해 이를 사용자에게 알려줄 필요가 있다면 여러 개의 Toast를 띄울 필요가 있습니다. 이를 위해 `array` 형태로 이를 관리하도록 하였습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n// toastType.ts\r\nexport interface ToastMessage {\r\n  id: number;\r\n  message: string;\r\n  type: \"alert\" | \"success\" | \"default\";\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n`atom` 작성 시에 활용한 `interface`입니다. 각 Toast를 구분해야 하기 때문에 `id`를 그 기준으로 결정하였습니다. `type`의 경우, Toast를 이용해 전달하고자 하는 메세지의 성격에 따라 구분하여 스타일을 적용할 수 있도록 확장성을 고려하여 추가하였습니다.\r\n\r\n### createPortal 사용하기\r\n\r\n`createPortal`을 사용하기에 앞서, 요소를 삽입할 `domNode`가 필요합니다. 우선 해당 요소를 생성하기 위한 `usePortal` 커스텀 훅을 작성했습니다.\r\n\r\n```jsx\r\nconst usePortal = (id: string) => {\r\n  const rootElementRef = useRef<HTMLElement | null>(null);\r\n\r\n  useEffect(() => {\r\n    let parentElement = document.querySelector(`#${id}`) as HTMLElement | null;\r\n\r\n    // id가 있는 element가 없으면 새로 생성\r\n    if (!parentElement) {\r\n      parentElement = document.createElement(\"div\");\r\n      parentElement.setAttribute(\"id\", id);\r\n      document.body.appendChild(parentElement);\r\n    }\r\n\r\n    rootElementRef.current = parentElement;\r\n\r\n\t\t// 더 이상 domNode가 사용되지 않으면 DOM을 제거\r\n    return () => {\r\n      if (parentElement && !parentElement.childElementCount) {\r\n        parentElement.remove();\r\n      }\r\n    };\r\n  }, [id]);\r\n\r\n  return rootElementRef.current;\r\n};\r\n\r\nexport default usePortal;\r\n```\r\n\r\n<br/>\r\n\r\n해당 훅은 `id`를 인자로 전달받아 `div` 태그를 생성한 후, return하는 역할을 담당합니다. 생성 과정에서 동일한 `id`를 가진 요소가 존재한다면 해당 요소를 사용하고, 아닐 경우 새로 생성하여 `body` 하위에 요소를 추가해줍니다. 여기서 생성된 `domNode`를 return받아 `createPortal`에서 활용하겠습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\n// ToastContainer.tsx\r\nconst ToastContainer = () => {\r\n  const toastList = useRecoilValue(toastListState)\r\n  const portalRoot = usePortal(\"toast-portal\")\r\n\r\n  return portalRoot\r\n    ? ReactDOM.createPortal(\r\n        <div className=\"fixed w-11/12 max-w-xs bottom-3 left-1/2 -translate-x-1/2 space-y-3\">\r\n          {toastList.map(toast => (\r\n            <Toast\r\n              key={toast.id}\r\n              toastKey={toast.id}\r\n              message={toast.message}\r\n              type={toast.type}\r\n            />\r\n          ))}\r\n        </div>,\r\n        portalRoot\r\n      )\r\n    : null\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n앞서 작성한 `usePortal`을 활용하여 `body` 하위에 생성된 `domNode`를 불러와 `createPortal`을 활용하여 해당 `domNode` 하위로 요소를 삽입하게 됩니다. 삽입하는 요소는 Toast들을 감싸는 container와 그 내부의 Toast들로, `recoil`로 관리하는 `state`를 불러와 하위 요소로 그려주게 됩니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nconst App = () => {\r\n  return (\r\n    <RecoilRoot>\r\n      <ToastContainer />\r\n      <BrowserRouter>\r\n        <Routes>\r\n\t\t\t\t\t...\r\n```\r\n\r\n<br/>\r\n\r\n이렇게 작성한 `ToastContainer`를 `App.tsx`와 같은 상위 요소에서 불러와 사용하게 됩니다.\r\n\r\n### useToast 커스텀 훅 작성하기\r\n\r\n지금까지 Toast를 담을 `domNode`의 생성과 해당 요소 내부에 Toast를 전역 상태 `toastListState` 를 기준으로 렌더링하는 부분까지 구현을 완료했습니다. 다만, 아직 어떻게 Toast를 추가할 수 있는지에 대한 방법이 없습니다.\r\n\r\n<br/>\r\n\r\nToast를 사용하고자 하는 component에서 전역 상태를 가져와 변경할 수도 있겠지만, Toast는 계속 유지되지 않기 때문에 특정 시간 이후에 사라지도록 설정해야 합니다. 이를 위해 편하게 Toast의 state에 메세지를 추가할 수 있는 `useToast` 커스텀 훅을 작성하였습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\ninterface UseToastProps {\r\n  message: string;\r\n  type: \"alert\" | \"success\" | \"default\";\r\n}\r\n\r\nexport const useToast = () => {\r\n  const [toastList, setToastList] = useRecoilState(toastListState)\r\n\r\n  const showToast = ({ message, type }: UseToastProps) => {\r\n    const newToast: ToastMessage = { id: Date.now(), message, type }\r\n    setToastList([...toastList, newToast])\r\n\r\n    setTimeout(() => {\r\n      setToastList(currentList =>\r\n        currentList.filter(toast => toast.id !== newToast.id)\r\n      )\r\n    }, TOAST_AVAILABLE_TIME)\r\n  }\r\n\r\n  return showToast\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n해당 훅은 `toastListState`에 메세지를 추가하고, 특정 시간 이후에 state에서 제거하도록 하는 `useToast` method를 반환하게 됩니다. 가장 처음에 `atom`을 작성하는 과정에서 `id`를 기억하시나요? Toast를 구분하여 특정 시간이 지나면 해당 Toast만 제거해주어야 하기 때문에 이 `id`가 필요합니다. 다만, 각 `id`는 unique해야 하기 때문에 현재 시각을 `id`로 지정하였습니다.\r\n\r\n<br/>\r\n\r\n`setTimeout`을 활용하여 특정 시간 이후에 생성한 Toast와 동일한 `id`를 가지는 State를 제거하여 업데이트하는 것으로 Toast를 사라지게 할 수 있습니다.\r\n\r\n## Toast 활용하기\r\n\r\n이렇게 작성한 Toast는 component에서 다음과 같이 활용할 수 있습니다.\r\n\r\n<br/>\r\n\r\n![](toast.gif)\r\n\r\n<br/>\r\n\r\n```jsx\r\nconst showToast = useToast();\r\n\r\n...\r\n\r\n<button onClick={() => showToast({ message: \"경고 메세지\", type: \"alert\" })}>\r\n     Alert Toast\r\n</button>\r\n```\r\n\r\n<br/>\r\n\r\n버튼을 클릭하여 `showToast`를 통해 Toast 메세지를 `toastListState`에 추가하여 Toast가 표시됩니다. 지금까지 구현한 Toast의 동작 과정을 표현하면 아래와 같습니다.\r\n\r\n![generated by chatGPT 4.0](graph.png)\r\n\r\n추가적으로 `onClick` 이벤트를 Toast component에 추가하여 클릭 시에 Toast가 바로 삭제될 수 있도록 기능을 구현하였습니다.\r\n\r\n<br/>\r\n\r\n```jsx\r\nconst handleClickToast = (id: number) => {\r\n  setToastList(() => toastList.filter(toast => toast.id !== id))\r\n}\r\n```\r\n\r\n## 포스팅을 마치며\r\n\r\n처음으로 `recoil`과 `Tailwind`, `createPortal`을 사용해보며 Toast를 구현하는 과정에서 크고 작은 이슈들이 있었습니다. 현재 구현한 Toast 역시 아직은 개선할 사항이 많습니다. Toast의 개수를 제한하는 것은 물론, Toast가 생성되는 위치를 쉽게 변경할 수 있도록 하는 등의 추가 기능도 생각해볼 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n긴 글 읽어주셔서 감사드립니다. 혹여나 틀린 부분이나 미흡한 부분이 있다면 지적해주시면 감사드리겠습니다.\r\n\r\n### 참고 자료\r\n\r\n- **[react-simple-toasts](https://www.npmjs.com/package/react-simple-toasts)**\r\n- **[[React] Toast 만들기](https://velog.io/@jsi06138/React-Toast-%EB%A7%8C%EB%93%A4%EA%B8%B0)**\r\n- **[React에서 Prop Drilling 해결 방법](https://slog.website/post/13)**\r\n- **[React Portals 공식 문서](https://ko.legacy.reactjs.org/docs/portals.html)**\r\n"},{"id":"3821daed-a3bb-5868-aadd-e637be8f7c1e","frontmatter":{"title":"2023 부스트캠프 Web-Mobile 8기 지원 후기","icon":"TbRocket","date":"July 08, 2023"},"fields":{"slug":"/boostcamp/apply/"},"rawMarkdownBody":"\r\n작년 하반기에 진행되었던 우테코 프리코스를 끝까지 완주하지 못했다는 아쉬움과 더불어 아직 많이 부족하다고 생각되는 개발 능력과 CS 지식 향상을 위해 올해 네이버 부스트캠프 8기에 지원하게 되었습니다.\r\n\r\n<br/>\r\n\r\n주변에서 `SAFFY`, `우테코`, `소마` 와 같이 정말 많이 들어왔던 코딩 캠프이기도 하고, 새로운 도전을 해보고자 지원을 결심하였습니다. 이번 글은 지원 과정에서 7기 지원 후기를 보며 많은 도움을 받았기에 동일한 목적으로 기록을 남기고자 하는 것이 목적입니다. **혹여나 글 내용이 문제가 있는 경우, 수정 혹은 삭제를 진행할 예정입니다.**\r\n\r\n# 부스트캠프 8기 모집 안내\r\n\r\n### 모집 안내\r\n\r\n- **인원** : 약 300명 내외\r\n\r\n- **분야** : 웹 풀스택(JavaScript), 모바일 iOS(Swift), 모바일 Android(Kotlin)\r\n\r\n### 지원 자격\r\n\r\n- 2023년 하반기에 풀타임(월 - 금, 10:00 - 19:00)으로 참여하실 수 있는 분\r\n\r\n- 분야에 관계없이 개발 경력 2년 미만인 분\r\n\r\n- 만 19세 이상 성인\r\n\r\n### 모집 일정\r\n\r\n> 자세한 내용은 [네이버 부스트캠프 공식 네이버 블로그](https://blog.naver.com/PostView.naver?blogId=boostcamp_official&logNo=223106301465&parentCategoryNo=&categoryNo=39&viewDate=&isShowPopularPosts=false&from=postView)를 확인해보세요.\r\n\r\n- **서류 접수** : 2023년 5월 2일 ~ 2023년 6월 12일 오전 11시\r\n\r\n- **서류 전형 결과 안내** : 2023년 6월 14일(수) 오후 12시 30분 경\r\n\r\n- **1차 코딩 테스트 응시료 납부 마감일** : 2023년 6월 15일(목) 자정\r\n- **1차 코딩 테스트 안내** : 2023년 6월 16일(금) 오후 5시 경\r\n\r\n- **1차 코딩 테스트 진행** : 2023년 6월 19일(월) 오후 7시 ~ 9시\r\n\r\n- **1차 코딩 테스트 결과** : 2023년 6월 21일(수) 오후 5시 경\r\n\r\n- **2차 코딩 테스트 진행** : 2023년 6월 24일(토) 오후 2시 ~ 4시 30분\r\n\r\n- **챌린지 합격자 발표** : 2023년 7월 5일 예정 > 7월 4일 오후 8시 경에 발표\r\n\r\n# 지원 과정\r\n\r\n멋쟁이사자처럼 10기 동아리 활동을 부원으로 참여하고, 현재 인하대학교 멋쟁이사자처럼 11기 대표를 담당하고 있지만, 개발자가 되기 위해 필요한 CS 지식과 더불어 기초가 부족하다고 생각하고 있었습니다. 간단하고 토이 프로젝트 수준인 개인 프로젝트도 진행하였지만, 새로운 라이브러리나 프레임워크를 사용하여 개발하여 새로운 지식을 습득하는 과정이 아닌, 기존에 학습했던 내용을 활용하는 수준이기도 했습니다.\r\n\r\n<br/>\r\n\r\n따라서 좀 더 새로운 도전을 하고자 네이버 부스트캠프에 지원하게 되었습니다. 무엇보다 부스트캠프는 **지속 가능한 개발자가 되기 위한 출발점 능력과 잠재력을 쌓아가는 곳**이라는 점이 매력적으로 다가왔습니다. 1회성으로 끝나는 활동이 아닌, 해당 활동을 바탕으로 **5년, 10년 후에도 꾸준히 성장중인 개발자, 혼자 성장하는 것이 아닌 같이 성장하는 개발자**를 목표로 함께 노력하고 싶어 지원하였습니다.\r\n\r\n# 서류 지원\r\n\r\n총 4개의 질문으로 이루어진 서류를 작성하였습니다.\r\n\r\n<br/>\r\n\r\n각 문항은 **400자 내외**로 정해져있으며, 질문들은 주로 **얼마나 자기주도적으로 노력했는가**가 주된 내용입니다. 저는 멋쟁이사자처럼 10기 동아리 활동 과정에서의 경험과 더불어 진행했던 프로젝트에 대한 경험을 녹여 작성하였습니다. 나름의 팁이라면 **네이버 부스트캠프에서의 인재상**을 참고하여 작성하는 것입니다.\r\n\r\n<br/>\r\n\r\n이와 관련해서는 꼭 **온라인 설명회**와 **수료생 MEET UP**에 참여하는 것을 추천드립니다. 네이버 부스트캠프를 경험한 캠퍼 선배님들의 조언과 더불어 네이버 부스트캠프와 관련된 보다 다양한 경험들을 들을 수 있었습니다.\r\n\r\n![노션 프로필](notion.png)\r\n\r\n링크와 파일을 제출할 수 있었는데, 이제까지 진행하고 참여했던 **프로젝트와 활동과 관련된 링크와 내용들을 정리한 notion 링크**를 첨부하였습니다.\r\n\r\n![1차 코딩테스트 안내 이메일](email1.png)\r\n\r\n이번에는 서류 지원 단계에서도 심사가 있었습니다. 다행히 합격하여 1차 코딩테스트를 준비하였습니다.\r\n\r\n# 1차 코딩 테스트\r\n\r\n1차 코딩 테스트는 **CS 문제**와 **코딩 테스트** 2가지로 이루어져 있습니다. 문제 비중은 아래와 같습니다. **CS 문제가 총 10문제, 코딩 테스트가 2문제로 총 12문제**로 이루어져 있습니다.\r\n\r\n<br/>\r\n\r\nCS 문제는 생각보다 까다롭다고 느껴졌습니다. 모르는 개념도 있었고, 검색을 해도 쉽게 답을 알아낼 수 없던 문제들도 있었습니다. 시험 종료 버튼을 누르는 그 순간까지도 고민을 하게 만들었던...\r\n\r\n<br/>\r\n\r\n코딩 테스트 문제는 난이도가 어렵기보다는 **얼마나 주어진 조건에 맞추어 구현을 잘 하는가**를 판단하기 위한 문제라고 느껴졌습니다. 두 문제 전부 테스트 케이스는 통과했으나, 모든 조건을 만족했는지는 의심이 되는 상태로 시간이 부족해 제출하게 되었습니다.\r\n\r\n<br/>\r\n\r\n모든 경우를 확인해보지 못해 확실한 2솔이라 할 수 없는 상황이기도 하고, CS 문제들도 고민만 하다 제출했던 느낌이 강해 2차 코딩 테스트를 볼 수 있을까 생각도 들었지만 감사하게도 1차 코딩 테스트 합격 메일을 받았습니다.\r\n\r\n![2차 코딩테스트 안내 이메일](email2.png)\r\n\r\n> 이번 8기 지원 과정에서는 **코딩 테스트 유형 예시**를 공개하였습니다.\r\n>\r\n> - [코딩 테스트 유형 예시](https://blog.naver.com/boostcamp_official/223085597916)를 참고하시어 미리 코딩 테스트 유형을 확인해보시는 것도 많은 도움이 되리라 생각합니다.\r\n> - 또한 CS 문제 대비를 위해 [부스트코스 CS50 강의](https://www.boostcourse.org/cs112)를 수강하였습니다. 부족한 CS 지식을 보충할 수 있는 강의라고 생각합니다.\r\n\r\n# 2차 코딩 테스트\r\n\r\n1차 코딩 테스트와 비슷한 방식으로 2차 코딩 테스트가 진행되었습니다. **2차 코딩 테스트는 총 6문제**로 이루어져 있으며, 그 중에 코딩 테스트 문제는 **3문제**로 이루어져 있습니다.\r\n\r\n<br/>\r\n\r\n수료생 MEET UP 행사에서도 상대적으로 2차 코딩 테스트의 구현 난이도와 조건이 더 복잡하고 어렵다는 이야기에 걱정이 많았습니다. 대부분 **프로그래머스 lv 2** 정도의 난이도로 느껴지는 문제들이지만, 역시 시간이 오래 걸리는 문제였습니다.\r\n\r\n<br/>\r\n\r\n이전보다 주어진 조건도 많았고, 예외 처리와 관련된 조건도 많았습니다. 1번 문제에서 최대한 코드와 주석을 깔끔하게 작성하고 틀리지 않도록 확인하기 위해 시간을 많이 사용했고, 2번 문제에서 대부분의 시간을 사용해서 3번은 문제도 읽지 못하고 테스트를 종료하였습니다.\r\n\r\n<br/>\r\n\r\n조금이라도 점수를 받을 수 있지 않을까 하는 마음에 3번 문제에서는 하나의 조건이라도 만족할 수 있도록 급하게 코드를 작성하였습니다. 1번과 2번의 테스트 케이스는 통과하였지만.. 특히나 2번은 코드를 작성하고 살펴보면서 틀린 부분을 정말 많이 수정했기 때문에, 완벽한 답안이라고 할 수 없었습니다.\r\n\r\n<br/>\r\n\r\n결국 애매한 1.5솔의 느낌으로 테스트를 종료하였습니다.\r\n\r\n> 나름의 팁이라면 **꼼꼼하게 문제를 읽고 조건을 잘 정리하시는 것을 추천**드립니다. 조건과 예외 처리가 많았기 때문에 이를 잘 정리하여 이해하고 코드로 작성하는 것이 중요할 것이라 생각합니다.\r\n\r\n# 대망의 결과...\r\n\r\n![합격 안내 이메일](email3.png)\r\n\r\n붙었으면 좋겠다.... 근데 떨어지면 어쩔 수 없지... 라고 생각하며 탈락하면 할 일들을 생각하고 있던 중에 감사하게도 합격 메일을 받아볼 수 있었습니다.\r\n\r\n<br/>\r\n\r\n앞으로 4주간의 챌린지 기간을 통해 많은 성장을 이루어낼 수 있었으면 좋겠습니다.\r\n\r\n# 그리고 받은 온보딩 키트\r\n\r\n![온보딩 키트](onboarding.png)\r\n\r\n이전 기수에게는 과자 타워를, 7기에서는 슬리퍼를 온보딩 키트로 받았다는 후기들을 살펴보고 이번 온보딩 키트에는 어떤 굿즈들이 들어있을까 기대가 많았습니다. 이번에는 정말 실용적인 굿즈들로 가득한 온보딩 키트가 배송되었습니다.\r\n\r\n<br/>\r\n\r\n무엇보다 최근 우산이 망가져서 2단 우산을 대충 들고다니던 참인데... 정말 필요한 3단 우산... 정말 만족스러운 온보딩 키트였습니다.\r\n"},{"id":"ca1b7024-5f1a-5271-b5d3-cad5e72383f5","frontmatter":{"title":"부스트캠프 웹・모바일 8기 챌린지 1주차 회고","icon":"TbBomb","date":"July 16, 2023"},"fields":{"slug":"/boostcamp/challenge-week1/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 챌린지 활동과 관련된 내용을 담고 있습니다.\r\n\r\n# 회고록 작성을 시작하며...\r\n\r\n정말 눈코 뜰 새 없이 바쁜 일주일이 지나갔습니다. 한 주를 마무리하는 7월 16일 일요일, 부스트캠프 8기 챌린지 캠퍼로써 5일간의 챌린지 기간동안 느낀점을 기록합니다.\r\n\r\n# 행복할 줄 알았던 일주일\r\n\r\n![제 상태는 위와 크게 다르지 않습니다.](cat.png)\r\n\r\n정말 붙으리라고는 생각하지 못했던 부스트캠프 8기 챌린지에 합격하여 캠퍼로 활동할 수 있는 기회가 주어졌습니다. OT와 더불어 1일차 활동을 시작하기 전까지는 설레였던 감정이 더 컸습니다. 주변에서 ‘부스트캠프 많이 힘들다더라’ 라는 이야기도 많이 들었지만, ‘에이 그래도 힘들면 얼마나 힘들겠어’ 라는 생각으로 활동을 시작했습니다.\r\n\r\n<br/>\r\n\r\n> 역시 사람은 입을 조심해야 합니다. ‘힘들면 얼마나 힘들겠어’? 정말 많이 힘들었습니다.\r\n\r\n<br/>\r\n\r\n자세한 일정까지는 공개할 수 없을 것 같아, 매일 주어지는 과제의 난이도와 공부량을 생각한다면… 정말 상상 그 이상이였습니다. 매일 새로운 개념에 매일 새로운 코드, 매일 새로운 과제가 쏟아졌습니다.\r\n\r\n<br/>\r\n\r\nCS지식을 주로 학습하는 챌린지 기간이기에 난이도가 있으리라고는 생각했지만 정말 어렵다고 느껴졌습니다. 이제까지 눈앞에 주어진 과제만 간간이 처리하던 저에게는 정말 놀라우리만큼 많고 어렵게 느껴졌습니다. 이번 글에서는 짧지만 그 험난한 과정에서 느끼고 새로 배운 점들을 공유해볼까 합니다.\r\n\r\n## 시간 분배\r\n\r\n정말 절실히 시간 분배의 기준이 필요했습니다. 새로운 개념을 먼저 정리하자니 과제를 수행할 시간이 부족했고, 개념을 잠시 내려두고 과제를 수행하자니 개념이 부족해 과제를 수행할 수 없었습니다. 이 둘을 모두 챙겨가기에는 시간적인 여유가 존재하지 않습니다.\r\n\r\n<br/>\r\n\r\n초반 과제들은 개념은 간단히 검색을 통해 읽고 과제를 수행하였습니다. 사실 이런 방식으로 어느정도 해결할 수 있는 과제들이기에 가능했다고 생각합니다. 하지만 후반 과제는 그렇지 않았습니다. 컴퓨터공학과 강의에서 분명 배운 내용임에도 정말 애매하게 기억에 남아있기 때문에 다시 공부할 필요도 있었지만, 과제의 볼륨도 크다고 생각했기에 어느 것을 먼저 처리해야할지 고민이 컸습니다.\r\n\r\n<br/>\r\n\r\n이러지도 저러지도 못한 끝에 그 무엇도 해낸 것이 없는 하루를 보냈을때는 자괴감과 후회로 가득차곤 했습니다. 하지만 후회만 하고 있을 시간이 없습니다. 어서 빨리 움직여야겠다고 생각했습니다.\r\n\r\n<br/>\r\n\r\n일주일을 돌이켜보며 다음과 같은 규칙을 스스로 만들어보았습니다. 이 규칙이 정답이라고 할 수는 없으므로 남은 챌린지 기간을 통해 보완할 예정입니다.\r\n\r\n<br/>\r\n\r\n> **하루를 알차게 보내는 규칙**\r\n>\r\n> - 개념 혹은 과제 어느 한 쪽에 너무 집중하지 말자.\r\n> - 과제와 관련된 개념을 간단히 1~2시간 정도 공부하자.\r\n> - 과제는 특정 시간이 되면 잠시 내려놓자.\r\n> - 과제도 중요하지만 개념도 중요하다. 개념 정리는 꼼꼼하게 하려고 노력해보자.\r\n> - 특정 시간을 주기로 삼아 주기적으로 진행도를 체크해보자. 길을 찾을 수 있는 나침반이 될 것이다.\r\n> - 정말 한 일이 없어도 새벽 2시에는 잠자리에 들자. 우리에게는 내일도 있다.\r\n> - 잠시 다른 캠퍼들도 둘러보자. 내가 하는 고민들에 대한 답을 찾을 수도 있다.\r\n\r\n## 멘탈과 건강 관리\r\n\r\n하루 12시간을 넘게 책상 앞에 앉아있다보니 스스로 몸이 망가져감을 느꼈습니다. 몸과 목이 점점 앞으로 굽어지면서 목도 아프고… 체력도 떨어져감을 느꼈습니다.\r\n\r\n<br/>\r\n\r\n사실 나빠지기 시작한건 몸만은 아니였습니다. 무의식중에 잘하는 다른 캠퍼분들과 스스로를 비교하기 시작했습니다. ‘저 사람은 저렇게 잘하는데 나는 늦게라도 해서 간극을 채워야지’ 라는 생각으로 무리하기도 했습니다.\r\n\r\n<br/>\r\n\r\n결국 무리하며 얻은 결과가 좋았냐, 고 되묻는다면 그렇지는 않았습니다. 어떻게든 빠르게 작업해서 제출해야지, 빠르게 개념을 학습해야지에 매몰되어 정작 중요한 것은 안중에도 없는 상황이 벌어졌습니다.\r\n\r\n<br/>\r\n\r\n그래서 보다 건강한 2주차를 위한 나름의 규칙을 만들어보았습니다. 이 역시 남은 챌린지 기간을 통해 보완할 예정입니다.\r\n\r\n<br/>\r\n\r\n> **하루를 아름답게 보내는 규칙**\r\n>\r\n> - 아무리 바빠도 2일에 한 번씩은 산책을 나가자. 많이도 아니고 30분만 걷자. 산책은 생각을 정리하는 훌륭한 도구다. 때로는 잡생각을 비워버릴 수 있는 기회이기도 하다.\r\n> - 다른 사람과 비교하지 말자. 잘하는 사람들은 그 실력 뒤에 노력한 시간이 존재할 것이다.\r\n> - 나만의 페이스와 기준을 찾자. 무조건 과제를 완벽하게 하는 것이 중요하지는 않다. 내 기준과 속도에 맞추어 차근차근 계단을 올라가는 것이 중요하다.\r\n> - 완벽함을 추구하는 것은 매우 위험하다. 완벽이라는 단어에 홀려 정작 중요한 일들을 신경쓰지 않았던 예전을 생각해보자.\r\n\r\n# 회고록을 마치며...\r\n\r\n짧은 시간임에도 불구하고 정말 느끼고 배운 것이 많은 활동이라는 생각이 들었습니다. 성급해하지 않고, 어제의 나와 오늘의 나를 생각하며 계단을 뛰어넘는 토끼보다는 차분히 천천히 하나씩 올라가는 거북이가 되기 위한 노력이 필요한 시점이라고 생각합니다.\r\n\r\n<br/>\r\n\r\n부족한 글을 읽어주셔서 감사드립니다. 똑같은 고민을 하는 누군가에게라도 이 글이 도움이 되었으면 합니다.\r\n"},{"id":"5fd752cb-7509-5513-b451-34d80cb770a3","frontmatter":{"title":"부스트캠프 웹・모바일 8기 멤버십 학습 스프린트 회고","icon":"TbPencilBolt","date":"October 01, 2023"},"fields":{"slug":"/boostcamp/membership/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 멤버십 활동과 관련된 내용을 담고 있습니다.\r\n\r\n# 늦은 회고, 하지만 중요하기에\r\n\r\n멤버십을 합격한 시점으로부터 5주라는 시간이 흘렀습니다. 중간에 틈이 날 때마다 '회고록을 작성해야지'라는 생각이 들면서도 막상 회고를 어떻게 작성해야 할지, 스스로 작성하는 회고가 맞는 방향인지에 대한 의구심과 더불어 '학습도 부족한데 무슨 회고록이야'는 생각에 회고가 많이 늦어졌습니다.\r\n\r\n<br/>\r\n\r\n4주간의 학습 스프린트 기간 동안 많은 성장을 이루어 내지는 못했지만 성장할 수 있는 기회를 엿볼 수 있어 이에 대해 정리하고 공유해 드리고자 회고록을 작성하게 되었습니다.\r\n\r\n# 내가? 멤버십에? 합격?\r\n\r\n![](mail.png)\r\n\r\n<br/>\r\n\r\n처음 합격 소식을 듣고 정말 놀랐습니다. 챌린지 기간 동안 스스로 많이 부족함을 느꼈고, 합격은 힘들 것이라 생각하고 마음 편히 쉬며 시간을 보내고 있었습니다. 사실 편하게 휴식을 취하려고 했다고 하더라도 막상 합격 발표 당일이 오면 설레는 마음을 감출 수는 없었습니다.\r\n\r\n<br/>\r\n\r\n결과는 정말 놀랍게도 합격. 기쁨도 잠시 걱정이 앞섰습니다. 챌린지 과정에서도 많이 부족했던 제가 멤버십 과정을 따갈 수 있을까와 더불어 1주 차부터 OT에 참석하지 못하고 예비군 훈련에 참여해야 했기 때문에 걱정이 이만저만이 아니었습니다.\r\n\r\n<br/>\r\n\r\n그렇게 시간이 흘러 예비군 훈련을 마친 다음 날인 금요일, 첫 멤버십 활동에 들어가게 됩니다.\r\n\r\n# 4주간의 경험, 새로운 문제들\r\n\r\n챌린지 활동은 짧은 기간 동안 다양한 주제를 다루었기에 내가 작성했던 코드를 다시 살펴보고 개선할 수 있는 기회가 거의 없었습니다. 멤버십 활동은 챌린지와는 달리 이러한 개선 과정도 경험할 수 있었기에 기대감이 컸습니다. 그렇다면 4주간의 활동에서 코드 개선도 하고, 많은 경험을 해봤냐 고 스스로 질문해 볼 수 있겠습니다.\r\n\r\n<br/>\r\n\r\n> 답은 '아니오' 입니다.\r\n\r\n### 생각보다 부족한 시간, 테스크 분배 미흡\r\n\r\n4주 내내 마음만 앞서 '어떻게든 주어진 조건들을 충족할 수 있도록 구현'하는 것에만 초점을 두었습니다. 당연히 마음만 앞섰기에 관련된 개념들도 겉으로만 간단하게 학습하고 넘어갔을 뿐더러, 사실상 '만족스럽게 구현했다'고 자신 있게 대답할 수 있는 기능도 없습니다.\r\n\r\n<br/>\r\n\r\n쉬어가는 주간에 4주간의 활동을 곰곰이 돌아보며 생각해 본 오점은 크게 2가지입니다. 첫 번째는 **'너무 마음만 앞섰다'**는 것입니다. 사실 늦게 시작한 만큼 당연히 늦어질 수밖에 없고, 이를 스스로 인지하고 나에게 맞는 속도를 찾아 작업을 진행해야 했습니다. 다만, 막상 스크럼 과정에서 다른 동료들의 구현 정도와 학습의 깊이를 스스로와 비교했을 때, 너무 극명하게 차이가 벌어졌기에 이와 같은 성급함이 생겼다고 생각합니다.\r\n\r\n<br/>\r\n\r\n두 번째는 내가 해야 할 **테스크를 정확하게 분배하지 못했다**는 점입니다. 적어도 일주일 단위로 어떠한 기능을 언제 구현해 볼 것인지, 어떠한 학습을 진행할 것인지에 대한 계획을 확실히 잡고 계획을 바탕으로 작업을 진행해야 했었습니다. 테스크를 정확히 분배하지 않았기에 무작정 'DB 테이블 구성하기'와 같은 모호한 테스크를 하루 안에 진행하겠다고 마음을 먹고 진행했고, 이로 인한 좋지 않은 결과가 이러한 악순환을 불러왔다고 생각합니다.\r\n\r\n### 코드에 의미를 담아라\r\n\r\n코드를 작성함에 있어서도 큰 문제가 있었습니다. 혹 어떤 코드를 작성했을 때, 누군가 '왜 그렇게 작성했나요'라고 질문한다면 이에 대해 명확하게 설명할 수 있으신가요? 4주간의 제가 작성한 코드를 돌아본다면 너무나 확실하게 '아니요'라고 대답할 것 같습니다.\r\n\r\n<br/>\r\n\r\n사실 코드에 의미를 담는다는 것은 다르게 해석한다면 **'내가 그 코드를 정확히 이해하고 있다'**는 의미일 수도 있겠습니다. 왜 이러한 코드를 작성했는지를 설명할 수 있다는 것은 코드의 문법을 떠나서 어떻게 동작하는지까지 이해하고 있다는 의미도 된다고 생각합니다. 다만 여기서 한 가지 더 고려할 점이 있겠습니다.\r\n\r\n### 한 번에 완벽한 코드를 작성할 수 있을까?\r\n\r\n작업 진행 속도가 더뎠던 가장 큰 이유 중 하나였습니다. 이후에 코드를 수정할 기회가 많이 없다고 생각해 시행착오 과정을 건너뛴 코드를 작성하기 위해 노력하였습니다. 사실 결과는 너무나 뻔했습니다. 한 번에 그런 코드를 작성할 수 있을리도 없었고, 이로 인해 정작 깊게 학습해 보고자 하는 개념은 등한시하는 결과를 낳았습니다.\r\n\r\n<br/>\r\n\r\n코드를 작성하는 과정에서 막연한 두려움이 있었습니다. '이렇게 작성하면 좋지 않은 코드일 것 같은데', '이렇게 구조를 가져가는 방식이 맞을까'와 같은 '코드 개선' 단계에서 고려해도 늦지 않은 부분에 대한 고민을 하고는 했습니다. 그렇기에 코드를 이해하는 것도 중요하지만, **무언가 부족하다고 해서 코드를 작성하는 것을 두려워하지는 않아야겠다**는 다짐을 하게 되었습니다.\r\n\r\n# 짧은 회고를 마치며\r\n\r\n상대적으로 많은 학습과 성장을 이루어 내지는 못했지만 이러한 경험과 고민, 생각들이 앞으로 나아갈 수 있는 발판이 될 수 있다고 생각합니다. 오늘의 회고가 앞으로 개발 능력 성장에 있어 **'퀀텀 점프'**가 될 수 있기를 바랍니다.\r\n"},{"id":"38bfd222-6876-5610-8d4d-48d540ddb8d6","frontmatter":{"title":"부스트캠프 웹・모바일 8기 챌린지 3주차 회고","icon":"TbBrain","date":"July 29, 2023"},"fields":{"slug":"/boostcamp/challenge-week3/"},"rawMarkdownBody":"\r\n> 해당 글은 부스트캠프 웹・모바일 8기 챌린지 활동과 관련된 내용을 담고 있습니다.\r\n\r\n# 3주차 회고록...\r\n\r\n챌린지 기간의 절반을 넘어서 드디어 3주차까지 마무리를 지었습니다. 아직 많이 부족하다고 생각하는데 벌써 3주차라니... 정말 많이 아쉽습니다. 이번주도 가볍게 회고를 시작하겠습니다.\r\n\r\n# 3주차, 뭐가 달라졌을까?\r\n\r\n![동글동글이... 너 덕분에 3주차를 이겨냈어...](cat.png)\r\n\r\n1, 2주차처럼 스스로에 대해 많은 고민과 생각을 하게 되는 일주일이었습니다. 진행 방식이 변경되면서 2주차까지 쌓아왔던 습관이 무너지기도 하고, 다시 쌓아올리기도 하면서 많은 부분을 느끼고 학습하게 된 한 주라고 생각합니다. 이번 주차에도 어떤 것들을 느끼고 배웠는지 여러분들과 공유하기 위해 글을 작성합니다. 2주차 회고록이 궁금하시다면 [여기](https://velog.io/@pexe99/2023-%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84-Web-Mobile-8%EA%B8%B0-2%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0)를 참고해주세요.\r\n\r\n## 무너진 공든 탑 얼레벌레 쌓아올리기\r\n\r\n2주차와는 달리 3주차에서는 주어진 미션에 대해 스스로 작성한 코드를 개선할 수 있는 시간이 주어졌습니다. 매번 과제를 진행할 때, 다 끝마치지 못한 부분도 아쉬웠지만 코드를 개선해보지 못한다는 점도 큰 아쉬움으로 남았습니다. 이번에는 직접 코드를 개선하고 그 과정을 공유해볼 수 있으니 정말 좋은 경험으로 남는 한 주일 것이라 생각하며 3주차 활동을 시작했습니다.\r\n\r\n<br/>\r\n\r\n> **하지만 그것은 크나큰 착각이었으니...**\r\n\r\n<br/>\r\n\r\n우선 지금까지의 문제 해결과 접근 방식이 잘못됨을 깨달았습니다. 2주동안 부스트캠프 챌린지 활동을 진행해오면서 모든 과제를 완성도 있게 진행하지는 못했지만, 적어도 절반 정도의 구현은 진행할 수 있도록 노력하였습니다. 하지만 이번 3주차 첫 과제가 저에게 있어서는 '실패할 수 있는 경험' 이었습니다.\r\n\r\n<br/>\r\n\r\n구현과 설계를 명확하게 구분하지 않고 경계를 유연하게 가져갈 수 있어야 하는데, 11일차에는 그러지 못했습니다. 개념 학습에 매몰되어 학습 정리만 진행하고 과제는 거의 진행하지 못했던 것이 기억에 남습니다. 개념 이해를 기반으로 코드를 작성하려 노력했던 방식이 항상 정답은 아니라는 사실을 깨달을 수 있던 주차라고 생각합니다. 과도하게 개념 이해에 매몰되어 학습과 구현 사이의 균형을 지키지 못했습니다.\r\n\r\n<br/>\r\n\r\n주어진 과제에 대한 구조를 이해하는 것도 중요하지만, 이를 완벽히 정하고 코드로 구현하려는 것은 집착에 불과하다는 결론을 내렸습니다. 전부를 한 번에 구현하려는 욕심이 오히려 독이 되었습니다. 보다 작은 단위로 구분하여 하나씩 올라갈 수 있는 방향으로 다시금 과정을 개선하기 위해 노력했습니다.\r\n\r\n<br/>\r\n\r\n> **동료 캠퍼분의 조언**\r\n>\r\n> 지금 너무 높은 계단을 한 번에 올라가려고 하고 있어요.\r\n>\r\n> 높이가 낮은 계단으로 나눠서 하나씩 올라갈 필요가 있어요.\r\n\r\n<br/>\r\n\r\n이를 바탕으로 남은 3주차에는 새로운 기준을 바탕으로 과제를 진행하고 학습하기 위해 노력했습니다.\r\n\r\n<br/>\r\n\r\n> **벽을 현명하게 넘어서는 방법**\r\n>\r\n> - 한 번에 모든 것을 이해하려고 하지 말자.\r\n> - 과제를 큰 단위로 구분하고, 큰 단위의 세부 내용을 구분하자.\r\n> - 세부 단위에 해당하는 내용을 이해했다면, 이를 구현해보자.\r\n> - 다른 기능을 너무 염두하지는 말자. 코드 작성이 두려워진다.\r\n\r\n## 코드 작성에 의도를 담아보자\r\n\r\n동료 캠퍼분들과 의견을 나누는 시간에 한 캠퍼분께서 질문을 주셨습니다.\r\n\r\n<br/>\r\n\r\n> **Q. 근데 class로 작성하신 이유가 있을까요?**\r\n\r\n<br/>\r\n\r\n생각하지 못한 질문이었습니다. 지금까지 class를 주로 사용해서 기능을 구분하고 코드로 구현했기 때문에 당연하게 class를 사용했었습니다. 지금 생각해본다면 굳이 class로 구현할 필요가 없는 부분이었습니다.\r\n\r\n<br/>\r\n\r\n> **의도를 담고 있지 않은 코드가 과연 의미가 있을까?**\r\n\r\n<br/>\r\n\r\n코드를 작성하는데 있어 익숙함이라는 단어 뒤에 숨지 않고 '내가 어떠한 의도로 이렇게 코드를 작성했는지' 한 번쯤은 되돌아볼 필요가 있을 것 같습니다. 어떠한 방식을 왜 사용했는지, 이에 대해 생각해보고 논의하는 것이 더 좋은 코드를 작성할 수 있는 하나의 방향이지 않을까 하는 깨달음을 얻었습니다.\r\n\r\n# 회고록을 마치며...\r\n\r\n항상 느끼는 부분이지만 지키지 못할 많은 계획은 오히려 중요한 것을 바라볼 수 없도록 눈 앞을 가리는 역할을 하게 되는 것 같습니다. 내가 스스로 지킬 수 있는 규칙들을 만들어가며 하나씩 루틴화하는 작업이 필요할 것 같습니다.\r\n\r\n<br/>\r\n\r\n부족한 글을 읽어주셔서 감사드립니다. 가벼운 마음으로 작성하였지만, 작성한 회고록이 다른 분들에게도 도움이 될 수 있었으면 좋겠습니다.\r\n"}]}}}